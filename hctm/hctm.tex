% ------------------------------------------------------------------------
% AMS-LaTeX Paper ********************************************************
% ------------------------------------------------------------------------
% Submitted:      Dec 15 2003
% Final Version:  
% Accepted:       
% ------------------------------------------------------------------------
% This is a journal top-matter template file for use with AMS-LaTeX.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO(mike): locating a closure at a name: how to translate a closure into a process that gets stuck into the cell



%\documentclass{tran-l}
%\documentclass[twocolumn]{amsart}
%\documentclass[]{amsart}
%\documentclass[]{sig-alternate}
\documentclass[]{acm_proc_article-sp}
%\documentclass[]{llncs}

%\documentclass[]{prentcsmacro}

%\usepackage[active]{srcltx} % SRC Specials for DVI Searching
\usepackage{url}
\usepackage[pdf]{pstricks}
\usepackage{pstricks-add, pst-grad, pst-plot}
\usepackage[tiling]{pst-fill}
\psset{linewidth=0.3pt,dimen=middle}
\psset{xunit=.70cm,yunit=0.70cm}
\psset{angleA=-90,angleB=90,ArrowInside=->,arrowscale=2}


% From Allen's stable.
\usepackage{bigpage}
\usepackage{bcprules}
%\usepackage{code}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{mathtools}
%\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{caption}
%\usepackage{multicol}

% Math
\newcommand{\maps}{\colon}
\newcommand{\NN}{\mathbb{N}}
% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\ldrb}{(\!(}
\newcommand{\rdrb}{)\!)}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
%\newcommand{\concat}{\mathbin{.}}
\newcommand{\concat}{\Rightarrow}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
\newcommand{\names}[1]{\mathbin{\mathcal{N}(#1)}}
\newcommand{\freenames}[1]{\mathbin{\mathcal{FN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\mathcal{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 \juxtap #2}
\newcommand{\outputp}[2]{#1 ! ( * #2 )}
\newcommand{\prefix}[3]{#1 ? ( #2 ) \concat #3}
\newcommand{\lift}[2]{#1 ! ( #2 )}
%\newcommand{\quotep}[1]{\lpquote #1 \rpquote}
\newcommand{\quotep}[1]{@#1}
\newcommand{\dropn}[1]{*#1}

\newcommand{\newp}[2]{\id{(}\newkw \; #1 \id{)} #2}
\newcommand{\bangp}[1]{\int #1}
\newcommand{\xbangp}[2]{\int_{#2} #1}
\newcommand{\bangxp}[2]{\int^{#2} #1}

\newcommand{\substp}[2]{\id{\{} \quotep{#1} / \quotep{#2} \id{\}}}
\newcommand{\substn}[2]{\id{\{} #1 / #2 \id{\}}}

\newcommand{\psubstp}[2]{\widehat{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\widehat{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{\id{(} #1 \id{)} #2}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}
\newcommand{\pmeaningof}[1]{\ldb #1 \rdb}
\newcommand{\nmeaningof}[1]{\ldrb #1 \rdrb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\entailm}{\mathbin{\vdash_{\mathfrak m}}} %matching
\newcommand{\entailp}{\mathbin{\vdash_{\mathfrak p}}} %behavioral
\newcommand{\entailv}{\mathbin{\vdash_{\mathfrak v}}} %validation
\newcommand{\congd}{\mathbin{\equiv_{\mathfrak d}}}
\newcommand{\congs}{\mathbin{\equiv_{\mathfrak s}}}
\newcommand{\congp}{\mathbin{\equiv_{\mathfrak p}}}
%\newcommand{\defneqls}{:\!=}
\newcommand{\defneqls}{\coloneqq}
%\newcommand{\logequiv}{\mathbin{\leftrightarrow}}

\newcommand{\barb}[2]{\mathbin{#1 \downarrow_{#2}}}
\newcommand{\dbarb}[2]{\mathbin{#1 \Downarrow_{#2}}}

% From pi-duce paper
\renewcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}

\newcommand{\opm}[2]{\overline{#1} [ #2 ]} % monadic
\newcommand{\ipm}[2]{{#1} ( #2 )} 
\newcommand{\ipmv}[2]{{#1} ( #2 )} % monadic
\newcommand{\parop}{\;|\;}    % parallel operator
\newcommand{\patmatch}[3]{#2 \in #3 \Rightarrow #1}
\newcommand{\sdot}{\, . \,}    % Space around '.'
\newcommand{\bang}{!\,}
%\newcommand{\fuse}[1]{\langle #1 \rangle}    
\newcommand{\fusion}[2]{#1 = #2} % fusion prefix/action
\newcommand{\rec}[2]{\mbox{\textsf{rec}} \, #1. \, #2}
\newcommand{\match}[2]{\mbox{\textsf{match}} \; #1 \; \mbox{\textsf{with}} \; #2}
\newcommand{\sep}{:}
\newcommand{\val}[2]{\mbox{\textsf{val}} \; #1 \; \mbox{\textsf{as}} \; #2}

\newcommand{\rel}[1]{\;{\mathcal #1}\;} %relation
\newcommand{\bisim}{\stackrel{.}{\sim}_b} %bisimilar
\newcommand{\wb}{\approx_b} %weak bisimilar
\newcommand{\bbisim}{\stackrel{\centerdot}{\sim}} %barbed bisimilar
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar
\newcommand{\bxless}{\lesssim}  %expansion less (amssymb required)
\newcommand{\bxgtr}{\gtrsim}  %expansion greater (amssymb required)
\newcommand{\beq}{\sim}    %barbed congruent
\newcommand{\fwbeq}{\stackrel{\circ}{\approx}}  %weak barbed congruent
\newcommand{\wbeq}{\approx}  %weak barbed congruent
\newcommand{\sheq}{\simeq}  %symbolic hypereq
\newcommand{\wbc}{\approx_{cb}}

% End piduce contribution

% rho logic

\newcommand{\ptrue}{\mathbin{true}}
\newcommand{\psatisfies}[2]{#1 \models #2}
\newcommand{\pdropf}[1]{\rpquote #1 \lpquote}
\newcommand{\pquotep}[1]{\lpquote #1 \rpquote}
\newcommand{\plift}[2]{#1 ! ( #2 )}
\newcommand{\pprefix}[3]{\langle #1 ? #2 \rangle #3}
\newcommand{\pgfp}[2]{\textsf{rec} \; #1 \mathbin{.} #2}
\newcommand{\pquant}[3]{\forall #1 \mathbin{:} #2 \mathbin{.} #3}
\newcommand{\pquantuntyped}[2]{\forall #1 \mathbin{.} #2}
\newcommand{\riff}{\Leftrightarrow}

\newcommand{\PFormula}{\mathbin{PForm}}
\newcommand{\QFormula}{\mathbin{QForm}}
\newcommand{\PropVar}{\mathbin{\mathcal{V}}}

\newcommand{\typedby}{\mathbin{\:\colon}}
\newcommand{\mixedgroup}[1]{\id{mixed($#1$)}}
\newcommand{\cast}[2]{\id{CAST AS} \; #1 \; (#2)}
\newcommand{\bslsh}{\mathbin{\id{\\}}}
\newcommand{\bslshslsh}{\mathbin{\id{\\\\}}}
\newcommand{\fslsh}{\mathbin{\id{/}}}
\newcommand{\fslshslsh}{\mathbin{\id{//}}}
\newcommand{\bb}[1]{\mbox{#1}}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\be}{\mathbin{=}}
\newcommand{\bd}{\mathbin{\buildrel {\rm \scriptscriptstyle def} \over \be}}
\newcommand{\ctcategory}[1]{\mbox{\bf #1}}

%GRAMMAR
\newlength{\ltext}
\newlength{\lmath}
\newlength{\cmath}
\newlength{\rmath}
\newlength{\rtext}

\settowidth{\ltext}{complex type name}
\settowidth{\lmath}{$xxx$}
\settowidth{\cmath}{$::=$}
\settowidth{\rmath}{\id{attributeGroup}}
\settowidth{\rtext}{repetition of $g$ between $m$ and $n$ times}

\newenvironment{grammar}{
  \[
  \begin{array}{l@{\quad}rcl@{\quad}l}
  \hspace{\ltext} & \hspace{\lmath} & \hspace{\cmath} & \hspace{\rmath} & \hspace{\rtext} \\
}{
  \end{array}\]
}

% Over-full v-boxes on even pages are due to the \v{c} in author's name
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small

% THEOREM Environments ---------------------------------------------------
 \newtheorem{thm}{Theorem}[subsection]
 \newtheorem{cor}[thm]{Corollary}
 \newtheorem{lem}[thm]{Lemma}
 \newtheorem{prop}[thm]{Proposition}
% \theoremstyle{definition}
 \newtheorem{defn}[thm]{Definition}
% \theoremstyle{remark}
 \newtheorem{rem}[thm]{Remark}
 \newtheorem{example}[thm]{Example}
 \numberwithin{equation}{subsection}
% MATH -------------------------------------------------------------------
 \DeclareMathOperator{\RE}{Re}
 \DeclareMathOperator{\IM}{Im}
 \DeclareMathOperator{\ess}{ess}
 \newcommand{\veps}{\varepsilon}
 \newcommand{\To}{\longrightarrow}
 \newcommand{\h}{\mathcal{H}}
 \newcommand{\s}{\mathcal{S}}
 \newcommand{\A}{\mathcal{A}}
 \newcommand{\J}{\mathcal{J}}
 \newcommand{\M}{\mathcal{M}}
 \newcommand{\W}{\mathcal{W}}
 \newcommand{\X}{\mathcal{X}}
 \newcommand{\BOP}{\mathbf{B}}
 \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
 \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
 \newcommand{\Real}{\mathbb{R}}
 \newcommand{\Complex}{\mathbb{C}}
 \newcommand{\Field}{\mathbb{F}}
 \newcommand{\RPlus}{\Real^{+}}
 \renewcommand{\Polar}{\mathcal{P}_{\s}}
 \newcommand{\Poly}{\mathcal{P}(E)}
 \newcommand{\EssD}{\mathcal{D}}
 \newcommand{\Lom}{\mathcal{L}}
 \newcommand{\States}{\mathcal{T}}
 \newcommand{\abs}[1]{\left\vert#1\right\vert}
% \newcommand{\set}[1]{\left\{#1\right\}}
%\newcommand{\seq}[1]{\left<#1\right>}
 \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
 \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}

%%% NAMES
\newcommand{\Names}{{\mathcal N}}
\newcommand{\Channels}{{\sf X}}
\newcommand{\Variables}{{\mathcal V}}
\newcommand{\Enames}{{\mathcal E}}
\newcommand{\Nonterminals}{{\mathcal S}}
\newcommand{\Pnames}{{\mathcal P}}
\newcommand{\Dnames}{{\mathcal D}}
\newcommand{\Types}{{\mathcal T}}

\newcommand{\fcalc}{fusion calculus}
\newcommand{\xcalc}{${\mathfrak x}$-calculus}
\newcommand{\lcalc}{$\lambda$-calculus}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\rhoc}{${\textsc{rho}}$-calculus}
\newcommand{\hcalc}{highwire calculus}
\newcommand{\dcalc}{data calculus}
%XML should be all caps, not small caps. --cb
%\newcommand{\xml}{\textsc{xml}}
\newcommand{\xml}{XML} 

\newcommand{\papertitle}{Higher category models of mobile process calculi}
% use static date to preserve date of actual publication
 \newcommand{\paperversion}{Draft Version 0.1 - Jan 7, 2015}

\newenvironment{toc}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
   \setlength{\parskip}{0pt}
 } \item }
{\end{list}}

\newenvironment{narrow}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
 } \item }
{\end{list}}

%%% ----------------------------------------------------------------------
\begin{document}
%\lstset{language=erlang}
\lstset{language=}

%These margin values appear to be relative to the bigpage package settings. --cb
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{6pt}

%\title{\huge{\papertitle}}
\title{\papertitle}

%\numberofauthors{3}
\author{
\alignauthor
Michael Stay\\
  \affaddr{Google}\\
  \email{\fontsize{8}{8}\selectfont stay@google.com} \\
\alignauthor 
L.G. Meredith\\
  \affaddr{Biosimilarity, LLC}\\
  \email{\fontsize{8}{8}\selectfont lgreg.meredith@biosimilarity.com}
}

%\address{Systems Biology, Harvard Medical School, Boston, Massachussetts, USA}

%\email{lg_meredith@hms.harvard.edu}

%\thanks{This work was completed during a visiting appointment at the Department of Systems Biology, Harvard Medical School.}

%\subjclass{Primary 47A15; Secondary 46A32, 47D20}

\keywords{ higher category theory, concurrency, message-passing, types, Curry-Howard }

%\date{April 6, 2002.}

%\dedicatory{}

%\commby{Daniel J. Rudolph}

%%% ----------------------------------------------------------------------

\begin{abstract}
\normalsize{ 

  We present an approach to modeling computational calculi using
  higher category theory. Specifically we present a fully abstract
  semantics for the {\pic}. The interpretation is consistent with
  Curry-Howard, interpreting terms as typed morphisms, while
  simultaneously providing an explicit interpretation of the rewrite
  rules of standard operational presentations as 2-morphisms. One of
  the key contributions is a method of restricting rewrites to
  specific contexts inspired by catalysis in chemical reactions.

}

\end{abstract}

\noindent
{\large \textbf{Submission to arXiv}}\\
\rule{6.25in}{0.75pt}\\\\\\

%%% ----------------------------------------------------------------------
\maketitle
%%% ----------------------------------------------------------------------

% \begin{center}
% \paperversion\\
% \end{center}

% \begin{toc}
% \tableofcontents
% \end{toc}

% \newpage
% ------------------------------------------------------------------------

\section{Introduction}

One of the major distinctions in programming language semantics has
been the division between denotational and operational semantics. In
the former computations are interpreted as mathematical objects
which---more often than not---completely unfold the computational
dynamics, and are thus infinitary in form. In the latter computations
are interpreted in terms of rewrite rules operating on finite
syntactic structure. Historically, categorical semantics for
programming languages, even variations such as games semantics
\cite{DBLP:conf/lics/McCusker96} which capture much more of the
intensional structure of computations, are distinctly denotational in
flavor \cite{DBLP:journals/iandc/Moggi91}. Meanwhile, operational
semantics continues to dominate in the presentation of calculi
underlying programming languages used in practice
\cite{DBLP:conf/aplas/MaffeisMT08}
\cite{DBLP:conf/oopsla/IgarashiPW99}
\cite{Politz:2013:PFM:2509136.2509536}.

Motivated, in part, by the desire to make a closer connection between
theory and practice, many efforts in the programming language
semantics, and in concurrency theory communities have begun to
investigate more direct categorical interpretations of operational
semantics. This paper finds its place in this latter context,
providing a fully abstract interpretation of the {\pic} in terms of a
higher categorical model of its operational semantics. In particular,
while it remains faithful to a Curry-Howard orientation, modeling
terms as typed morphisms, it models the computational dynamics of the
calculus, its rewrite rules, as 2-morphisms. One of the goals has been
to provide a modular semantics to address a range of features and
modeling options typically associated with the {\pic}. For example, a
significant bifurcation occurs in the treatment of names with Milner's
original calculus hiding all internal structure of names
\cite{milner91polyadicpi}, while the $\rho$-calculus variant provides
a reflective version in which names are the codes or processes
\cite{DBLP:journals/entcs/MeredithR05}. The semantics presented here
is capable of providing a categorical interpretation of both variants.

Of particular interest to theoreticians and implementers, the
semantics shines light on a key difference between the categorical and
computational machinery it interprets. The latter is intrinsically
lazy in the sense that all contexts where rewrites can apply must be
explicitly spelled out (cf the context rules in section
\ref{section:opsem}), while the former is intrinsically eager; in
fact, one of the contributions of the paper is the delineation of an
explicit control mechanism to prevent unwanted rewrites that would
otherwise create an insurmountable divergence between the two
formalisms. 

\subsubsection{Related work}

%Montanari, et al have considered double category models of the {\pic}.

This paper draws inspiration from \cite{DBLP:conf/lics/Seely87} and
\cite{DBLP:journals/tcs/Hilken96}, but also seeks a more direct
account of what works in modern day operational semantics. In his
seminal paper \cite{DBLP:journals/mscs/Milner92} Milner provided the
template still used today for specifying computational calculi,
presenting the {\pic} in terms of a freely generated algebra
quotiented by a structural equivalence relation that is then subject
to some rewrite rules. This constitutes the modern view of structured
operational semantics \cite{Plotkin04theorigins}. In the latter part
of his research Milner focused on finding a satisfying relationship
between a categorical presentation of the rewrite rules and the notion
of bisimulation \cite{DBLP:conf/concur/LeiferM00}. While this work did
not explicitly employ higher categorical techniques, it spawned a
variety of 2-categorical investigations designed to capture and recast
bisimulation equivalences in terms of 2-morphisms
\cite{Sassone02derivingbisimulation}. Hershowitz has developed an even
more ambitious program of categorifying the whole of the operational
semantics framework from the presentation of higher order syntax (or
terms with binding constructors like {\pic} or $\lambda$-calculus), to
rewrite rules \cite{hirschowitzcc2c}.

The present work, while presenting a modular semantics, and some tools
that apply to a number of calculi, is focused on providing a direct
account of the {\pic}, rather than providing a framework for
interpreting a number of computational calculi. Moreover, our
particular reconciliation of operational laziness with categorical
eagerness introduces an explicit resource sensitivity, which we have
not seen before in the theoretical literature, yet is remarkably
similar to resource constraints in actual implementations of
concurrent and distributed computations.

\subsubsection{Organization of the rest of the paper}

In the remainder of the paper we present the core fragment of the
calculus we model followed by a manifest of the categorical equipment
needed to faithfully model it. Then we give the semantics function an
sketch a proof that the interpretation is fully abstract.

%%% ----------------------------------------------------------------------

\section{The calculus}

One notable feature of the {\pic} is its ability to succinctly and
faithfully model a number of phenomena of concurrent and distributed
computing. Competition for resources amongst autonomously executing
processes is a case in point. The expression
\begin{equation*}
  x?( y ) \Rightarrow P \juxtap x!( u ) \juxtap x?( v ) \Rightarrow Q
\end{equation*}
is made by composing three processes, two of which, $x?( y )
\Rightarrow P$ and $x?( v ) \Rightarrow Q$ are seeking input from
channel $x$ before they launch their respective continuations, $P$
and/or $Q$; while the third, $x!( u )$, is supplying output on that
same said channel. Only one of the input-guarded processes will win,
receiving $u$ and binding it to the input variable, $y$, or
respectively, $v$ in the body of the corresponding continuation --
while the loser remains in the input-guarded state awaiting input
along channel $x$. The calculus is equinanimous, treating both
outcomes as equally likely, and in this regard is unlike its
sequential counterpart, the $\lambda$-calculus, in that it is not
\emph{confluent}. There is no guarantee that the different branches of
computation must eventually converge. Note that just adding a
$\mathsf{new}$-scope around the expression
\begin{equation*}
  (\mathsf{new}\; x)( x?( y ) \Rightarrow P \juxtap x!( u ) \juxtap x?( v ) \Rightarrow Q )
\end{equation*}
ensures that the competition is for a local resource, hidden from any
external observer.

\subsection{Our running process calculus}

\subsubsection{Syntax}
\label{syntax}
\begin{grammar}
{P} \bc \pzero & \mbox{stopped process} \\
       \;\;\; \bm \; {x}{?}{( y_1, \ldots, y_n )} \Rightarrow {P} & \mbox{input} \\
       \;\;\; \bm \; {x}{!}{( y_1, \ldots, y_n )} & \mbox{output} \\
%       \;\;\; \bm \; {M}{+}{N} & \mbox{choice} \\
%{ P, Q } \bc M & \mbox{include IO processes} \\                                
       \;\;\; \bm \; (\mathsf{new}\; x){P} & \mbox{new channel} \\
       \;\;\; \bm \; {P} \juxtap {Q} & \mbox{parallel} \\                                
\end{grammar}

\subsubsection{Free and bound names}

\begin{equation*}
  \begin{aligned}
    & \freenames{\pzero} \defneqls \emptyset \\
    & \freenames{{x}{?}{( y_1, \ldots, y_n )} \Rightarrow {P}} \defneqls \\
    & \;\;\;\;\;\{ x \} \cup (\freenames{P} \setminus \{ y_1, \ldots y_n \}) \\
    & \freenames{{x}{!}{( y_1, \ldots, y_n )}} \defneqls \{ x, y_1, \ldots, y_n \} \\
    & \freenames{(\mathsf{new}\; x){P}} \defneqls \freenames{P} \setminus \{x\} \\    
    & \freenames{{P} \juxtap {Q}} \defneqls \freenames{P} \cup \freenames{Q} \\
  \end{aligned}
\end{equation*}

An occurrence of $x$ in a process $P$ is \textit{bound} if it is not
free. The set of names occurring in a process (bound or free) is
denoted by $\names{P}$.

\subsubsection{Structural congruence}

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence containing $\alpha$-equivalence, $\alphaeq$, making
$( P, |, 0 )$ into commutative monoids and satisfying

\begin{equation*}  
  (\mathsf{new}\; x)(\mathsf{new}\; x){P} \scong (\mathsf{new}\; x)P
\end{equation*}
\begin{equation*}  
  (\mathsf{new}\; x)(\mathsf{new}\; y){P} \scong (\mathsf{new}\; y)(\mathsf{new}\; x)P
\end{equation*}
\begin{equation*}  
  ((\mathsf{new}\; x){P}) \juxtap {Q} \scong (\mathsf{new}\; x)({P} \juxtap {Q})
\end{equation*}

\subsubsection{Operational Semantics}\label{section:opsem}
 
\infrule[Comm]
{ |\vec{y}| = |\vec{z}| }
%{P_1 + {{ x_{0}{?}{(}{\vec{y}}{)} \concat {P}}\juxtap {x_{1}}{!}{(}{\vec{z}}{)} + P_2}
{{{ x{?}{(}{\vec{y}}{)} \concat {P}}\juxtap {x}{!}{(}{\vec{z}}{)}}
\red {{P}{\{}\quotep{\vec{z}}{/}{\vec{y}}{\}}}}

In addition, we have the following context rules:

\infrule[Par]{{P} \red {P}'}{{{P} \juxtap {Q}} \red {{P}' \juxtap {Q}}}

\infrule[New]{{P} \red {P}'}{{(\mathsf{new}\; x){P}} \red {(\mathsf{new}\; x){P}'}}

\infrule[Equiv]{{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}

\subsubsection{Bisimulation}

\begin{defn}
An \emph{observation relation}, $\downarrow$ is the smallest relation satisfying the rules
below.

\infrule[Out-barb]{ }
      {{x}!(\vec{y}) \downarrow x}
\infrule[Par-barb]{\mbox{$P\downarrow x$ or $Q\downarrow x$}}
      {{P} \juxtap {Q} \downarrow x}

We write $P \Downarrow x$ if there is $Q$ such that 
$P \wred Q$ and $Q \downarrow x$.
\end{defn}

Notice that $\prefix{x}{y}{P}$ has no barb.  Indeed, in {\pic} as well
as other asynchronous calculi, an observer has no direct means to
detect if a sent message has been received or not.

\begin{defn}
%\label{def.bbisim}
An \emph{barbed bisimulation}, is a symmetric binary relation 
${\mathcal S}$ between agents such that $P\rel{S}Q$ implies:
\begin{enumerate}
\item If $P \red P'$ then $Q \wred Q'$ and $P'\rel{S} Q'$.
\item If $P\downarrow x$, then $Q\Downarrow x$.
\end{enumerate}
$P$ is barbed bisimilar to $Q$, written
$P \wbbisim Q$, if $P \rel{S} Q$ for some barbed bisimulation ${\mathcal S}$.
\end{defn}

\section{Categorical machinery}

We take our models in 2-categories with an underlying symmetric monoidal closed category; the 2-categories Cat (categories, functors, and natural transformations) and Rel (sets, relations, and implications) are examples.  We denote the monoidal unit object by $I$, the tensor product by $\otimes,$ the $n$th tensor power of an object $X$ by $X^{\otimes n},$ and the internal hom by a lollipop $\multimap$.

\section{The interpretation}

Given the abstract syntax of a term calculus like that in section \ref{syntax}, we introduce an object in our 2-category for each parameter of the calculus.  We introduce 1-morphisms for each term constructor, 2-morphisms for each reduction relation, and equations for structural equivalence; we also add 1-morphisms to mark contexts in which reductions may occur.

The {\pic} is parametric in a set of names and a set of processes, so we have objects $N$ and $P$.  Since names can be reused in the {\pic,} we also add 1-morphisms and equations to make $N$ be a cocommutative comonoid.  We denote comultiplication by $\Delta\maps N \to N \otimes N$ and counit by $\delta\maps N \to I.$  If the underlying category is cartesian, $I$ is the terminal object, $N$ is a comonoid in a unique way, and $\Delta$ and $\delta$ are duplication and deletion, respectively.  

In the {\pic,} all reductions occur at the topmost context, so we have one unary morphism from $P$ to $P$.  There are some benefits to constructing the top context marker out of the existing binary morphism $|\maps P \otimes P \to P$ and a unary morphism $COMM\maps I \to P;$ we'll talk about some of the benefits in the conclusion.

The theory of the {\pic} is the free symmetric monoidal closed 2-category on
\begin{itemize}
  \item an objects $N$ for names,
    \[\begin{pspicture}(0,0)(0,2)
      \pnode(0,2){A}
      \pnode(0,0){B}
      \nccurve{A}{B} \naput{$N$}
    \end{pspicture}\]
  \item an object $P$ for processes,
    \[\begin{pspicture}(0,0)(0,2)
      \pnode(0,2){A}
      \pnode(0,0){B}
      \nccurve{A}{B} \naput{$P$}
    \end{pspicture}\]
	\item a 1-morphism $\Delta\maps N \to N \otimes N,$
    \[\begin{pspicture}(0,0)(0,4)
			\pnode(1,4){A}
      \pnode(1,2){B}
			\nccurve{A}{B} \naput{$N$}
			\pnode(0,0){C}
			\pnode(2,0){D}
			\nccurve[angleA=225]{B}{C} \naput{$N$}
			\nccurve[angleA=315]{B}{D} \naput{$N$}
    \end{pspicture}\]
	\item a 1-morphism $\delta\maps N \to I,$
    \[\begin{pspicture}(0,0)(0,2.5)
      \rput(0,0){\cnode*{2pt}{A}}
      \pnode(0,1){B}
      \nccurve{B}{A} \naput{$N$}
    \end{pspicture}\]  
  \item a 1-morphism $0\maps I \to P,$
    \[\begin{pspicture}(0,0)(0,2.5)
      \rput(0,2){\ovalnode{A}{$0$}}
      \pnode(0,0){B}
      \nccurve{A}{B} \naput{$P$}
    \end{pspicture}\]  
  \item a 1-morphism $|\maps P \otimes P \to P,$
    \[\begin{pspicture}(0,0)(0,4)
      \rput(1,2){\ovalnode{A}{$|$}}
      \pnode(1,0){B}
      \nccurve{A}{B} \naput{$P$}
      \pnode(0,4){C}
      \nccurve[angleB=135]{C}{A} \naput{$P$}
      \pnode(2,4){D}
      \nccurve[angleB=45]{D}{A} \naput{$P$}
    \end{pspicture}\]
  \item a 1-morphism $?_n\maps N \otimes (N^{\otimes n} \multimap P) \to P$ for each natural number $n \ge 0,$
    \[\begin{pspicture}(0,0)(0,4)
      \rput(1,2){\ovalnode{A}{$?_n$}}
      \pnode(1,0){B}
      \nccurve{A}{B} \naput{$P$}
      \pnode(0,4){C}
      \nccurve[angleB=135]{C}{A} \naput{$N$}
      \pnode(1.75,4){D}
      \nccurve[angleA=65,angleB=-90]{A}{D} \ncput[npos=.75]{\pnode{clasp1}}
      \pnode(2.25,4){E}
      \nccurve[angleB=35]{E}{A} \naput{$N^{\otimes n}\multimap P$} \ncput[npos=.25]{\cnode{4pt}{clasp2}}
      \nccurve[angleA=0,angleB=180,ArrowInside=]{clasp1}{clasp2}
    \end{pspicture}\]
  \item a 1-morphism $!_n\maps N \otimes N^{\otimes n} \to P$ for each natural number $n \ge 0,$
    \[\begin{pspicture}(0,0)(0,4)
      \rput(1,2){\ovalnode{A}{$!_n$}}
      \pnode(1,0){B}
      \nccurve{A}{B} \naput{$P$}
      \pnode(0,4){C}
      \nccurve[angleB=135]{C}{A} \naput{$N$}
      \pnode(2,4){D}
      \nccurve[angleB=45]{D}{A} \naput{$N^{\otimes n}$}
    \end{pspicture}\]
  \item a 1-morphism $COMM\maps I \to P,$
    \[\begin{pspicture}(0,0)(0,2.5)
      \rput(0,2){\ovalnode{A}{$COMM$}}
      \pnode(0,0){B}
      \nccurve{A}{B} \naput{$P$}
    \end{pspicture}\]  
  \item equations making $(P, |, 0)$ into a commutative monoid,
  \item equations making $(N, \Delta, \delta)$ into a cocommutative comonoid, and
  \item a 2-morphism $comm_n$ encoding the COMM rule for each natural number $n \ge 0.$
    \[\begin{pspicture}(-.5,0)(10,8)
      \pnode(0,8){A}
      \pnode(0,7){B}
      \pnode(1,8){C}
      \rput(1,5){\ovalnode{D}{$!_n$}}
      \nccurve{A}{B} \nbput{$N$} 
      \nccurve[angleA=225,angleB=135]{B}{D}
      \nccurve[angleB=45]{C}{D} \naput[npos=.25]{$N^{\otimes n}$}
      \pnode(5,8){E}
      \pnode(6,8){F}
      \rput(5,5){\ovalnode{G}{$?_n$}}
      \nccurve[angleA=315,angleB=135]{B}{G}
      \nccurve[angleA=90,angleB=270]{G}{E} \ncput[npos=.75]{\pnode{clasp1}}
      \nccurve[angleB=45]{F}{G} \ncput[npos=.25]{\cnode{4pt}{clasp2}} \naput{$N^{\otimes n} \multimap P$}
      \nccurve[angleA=0,angleB=180,ArrowInside=]{clasp1}{clasp2}
      \rput(8,5){\ovalnode{H}{$COMM$}}
      \rput(2.5,3){\ovalnode{I}{$|$}}
      \rput(3.5,1.5){\ovalnode{J}{$|$}}
      \pnode(3.5,0){K}
      \nccurve[angleB=135]{D}{I} \nbput{$P$}
      \nccurve[angleB=45]{G}{I} \naput{$P$}
      \nccurve[angleB=135]{I}{J} \nbput{$P$}
      \nccurve[angleB=45]{H}{J} \naput{$P$}
      \nccurve{J}{K} \nbput{$P$}
    \end{pspicture}\]
    \[comm_n\Downarrow\]
    \[\begin{pspicture}(-.5,0)(10,8)
      \pnode(0,8){A}
      \rput(0,7){\cnode*{2pt}{B}}
      \pnode(1,8){C}
      \nccurve{A}{B} \nbput{$N$} 
      \rput(2.5,5){\cnode{18pt}{D}}
      \nccurve[angleB=135]{C}{D} \naput{$N^{\otimes n}$} \ncput[npos=1]{\pnode{Z}}
      \pnode(5,8){E}
      \pnode(6,8){F}
      \nccurve[angleA=90,angleB=270]{D}{E} \ncput[npos=.75]{\pnode{clasp1}} \ncput[npos=0]{\pnode{Y}}
      \nccurve[angleB=45]{F}{D} \ncput[npos=.25]{\cnode{4pt}{clasp2}} \naput{$N^{\otimes n} \multimap P$} \ncput[npos=1]{\pnode{X}}
      \nccurve[angleA=0,angleB=180,ArrowInside=]{clasp1}{clasp2}
      \rput(8,5){\ovalnode{H}{$COMM$}}
      \rput(3.5,1.5){\ovalnode{J}{$|$}}
      \pnode(3.5,0){K}
      \nccurve[angleB=135]{D}{J} \nbput{$P$} \ncput[npos=0]{\pnode{W}}
      \nccurve[angleB=45]{H}{J} \naput{$P$}
      \nccurve{J}{K} \nbput{$P$}
      \nccurve[angleA=315,angleB=270]{Z}{Y}
      \nccurve[angleA=225,angleB=90]{X}{W}
      \rput(2,5){$ev$}
    \end{pspicture}\]
\end{itemize}
\subsection{Semantics}
\begin{description}
  \item $\meaningof{Q}_{top} \defneqls | \circ (\meaningof{Q} \otimes COMM) \circ \freenames{Q}$
  \item $\meaningof{\pzero} \defneqls$
  \[\begin{pspicture}(0,0)(0,2)
    \rput(0,2){\ovalnode{A}{$0$}}
    \pnode(0,0){B}
    \nccurve{A}{B} \naput{$P$}
  \end{pspicture}\]
  \item $\meaningof{{x}{?}{( y_1, \ldots, y_n )} \Rightarrow {Q}} \defneqls$
		\[\begin{pspicture}(0,0)(0,4.5)
      \rput(1,2){\ovalnode{A}{$?_n$}}
      \pnode(1,0){B}
      \nccurve{A}{B} \naput{$P$}
      \pnode(0,4){C}
      \nccurve[angleB=135]{C}{A} \naput{$N$}
			\rput(2.5,4){\ovalnode{D}{$curry(\meaningof{Q})$}}
      \nccurve[angleA=65,angleB=-135]{A}{D} \ncput[npos=.65]{\pnode{clasp1}}
      \nccurve[angleA=-90,angleB=35]{D}{A} \naput{$N^{\otimes n}\multimap P$} \ncput[npos=.25]{\cnode{4pt}{clasp2}}
      \nccurve[angleA=0,angleB=180,ArrowInside=]{clasp1}{clasp2}
    \end{pspicture}\]
  \item $\meaningof{{x}{!}{( y_1, \ldots, y_n )}} \defneqls$
  \[\begin{pspicture}(-1,0)(0,4.5)
    \rput(1,2){\ovalnode{A}{$!_n$}}
		\pnode(1,0){B}
    \nccurve{A}{B} \naput{$P$}
    \pnode(0,4){C}
    \nccurve[angleB=135]{C}{A} \naput{$N$}
    \pnode(2,4){D}
    \nccurve[angleB=45]{D}{A} \naput{$N^{\otimes n}$}
  \end{pspicture}\]
  \item $\meaningof{\binpar{Q}{Q'}} \defneqls$
	\[\begin{pspicture}(-1,0)(0,3.5)
		\rput(0,3){\ovalnode{A}{$\meaningof{Q}$}}
		\rput(2,3){\ovalnode{B}{$\meaningof{Q'}$}}
		\rput(1,1.5){\ovalnode{C}{$|$}}
		\pnode(1,0){D}
		\nccurve[angleB=135]{A}{C} \nbput{$P$}
		\nccurve[angleB=45]{B}{C} \naput{$P$}
		\nccurve{C}{D} \naput{$P$}
	\end{pspicture}\]
\end{description}
The first point deserves a bit more explanation.  At the top level, we put the process in parallel with COMM, since that's our context marker.  For terms at lower levels, all names are internal wires; only at the top level do we bind inputs to particular names.  For example, suppose that the top level term is ${x}{?}{( y_1, \ldots, y_n )} \Rightarrow {Q}$ and that only $y_1, \ldots, y_n$ are free in $Q$; then only $x$ is free in ${{x}{?}{( y_1, \ldots, y_n )} \Rightarrow {Q}}$ and the interpretation is
\begin{center}
	\begin{pspicture}(2,-4)(2,5.5)
	  \rput(1,2){\ovalnode{A}{$?_n$}}
		\rput(1,-1){\ovalnode{B}{$|$}}
	  \nccurve[angleB=135]{A}{B} \naput{$P$}
		\rput(0,5){\ovalnode{C}{$x$}}
	  \nccurve[angleB=135]{C}{A} \naput{$N$}
		\rput(2.5,4){\ovalnode{D}{$curry(\meaningof{Q})$}}
	  \nccurve[angleA=65,angleB=-135]{A}{D} \ncput[npos=.65]{\pnode{clasp1}}
	  \nccurve[angleA=-90,angleB=35]{D}{A} \naput{$N^{\otimes n}\multimap P$} \ncput[npos=.25]{\cnode{4pt}{clasp2}}
	  \nccurve[angleA=0,angleB=180,ArrowInside=]{clasp1}{clasp2}
		\rput(3,1){\ovalnode{E}{$COMM$}}
		\nccurve[angleB=45]{E}{B}
		\pnode(1,-3){F}
		\nccurve{B}{F} \naput{$P$}
	\end{pspicture}
\end{center}

\subsubsection{Bisimulation again}
In this setting we can provide a direct interpretation of observation
and bisimulation. Roughly speaking, $\meaningof{P}$ reduces to
$\meaningof{Q}$ just when we can apply the 2-morphism to the former to
produce that latter.

\subsubsection{Full abstraction}

\begin{thm}[full abstraction]
  $P \wbbisim Q \iff \meaningof{P} \wbbisim \meaningof{Q}$
\end{thm}

\section{Conclusions and future work}
We presented a fully abstract higher categorical semantics for the
{\pic}. Our semantics can be seen as a natural extension of
Curry-Howard in the categorical setting: if terms are taken to be
1-morphisms, then rewrites between terms should be 2-morphisms. Such
an approach is natural from another perspective in that it makes
comparison with operational semantics considerably simpler, at least
conceptually. To that end, we have already applied the approach to
models of other milestone computational calculi, such as the lazy
$\lambda$-calculus, with some initial success and hope to report on
that in subsequent papers. 

Perhaps more importantly, establishing connections like this between
two different computational frameworks should allow for transport of
other key conceptual tools. Here, we were able to transport a version
bisimulation to the categorical setting in a simple and
straightforward manner. It would be quite interesting to be able to
transport categorical notions of typing back to the process
setting. For example, Mellies and Zeilberger's refinement types,
expressed as functors, suggests an intriguing approach to a more
categorical account of behavioral types.

\paragraph{Acknowledgments.}
We would like to acknowledge Tom Hershowitz for asking some thoughtful
and stimulating questions about earlier versions of this work.

% ------------------------------------------------------------------------
%GATHER{Xbib.bib}   % For Gather Purpose Only
%GATHER{Paper.bbl}  % For Gather Purpose Only
\bibliographystyle{amsplain}
\bibliography{hctm}

% ------------------------------------------------------------------------



% ------------------------------------------------------------------------

\end{document}
% ------------------------------------------------------------------------
