\documentclass{llncs}
\usepackage{mathpartir}
\usepackage{bigpage}
\usepackage{bcprules}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{stmaryrd}

\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\maps}{\colon}
\newcommand{\Th}{\mathrm{Th}}
\newcommand{\Gph}{\mathrm{Gph}}
\newcommand{\FinSet}{\mathrm{FinSet}}
\newcommand{\FPGphCat}{\mathrm{FPGphCat}}
\newcommand{\Set}{\mathrm{Set}}
\newcommand{\Cat}{\mathrm{Cat}}
\newcommand{\Calc}{\mathrm{Calc}}
\newcommand{\Mon}{\mathrm{Mon}}
\newcommand{\BoolAlg}{\mathrm{BoolAlg}}
\renewcommand{\Form}{\mathrm{Form}}
\newcommand{\leftu}{\mathrm{left}}
\newcommand{\rightu}{\mathrm{right}}
\newcommand{\send}{\mathrm{send}}
\newcommand{\recv}{\mathrm{recv}}
\newcommand{\comm}{\mathrm{comm}}
\renewcommand{\quote}[1]{``#1"}
\newcommand{\deref}[1]{\mathrm{eval}(#1)}
\newcommand{\op}{\mathrm{op}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\pic}{$\pi$-calculus}

% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\ldrb}{(\!(}
\newcommand{\rdrb}{)\!)}
\newcommand{\lrbb}{(\!|}
\newcommand{\rrbb}{|\!)}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
%\newcommand{\plogp}{:\!-}
\newcommand{\plogp}{\leftarrow}
%\newcommand{\plogp}{\coloneq}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
\newcommand{\concat}{\mathbin{.}}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
\newcommand{\names}[1]{\mathbin{\mathcal{N}(#1)}}
\newcommand{\freenames}[1]{\mathbin{\mathsf{FN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\mathsf{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 | #2}
\newcommand{\outputp}[2]{#1!(#2)}
\newcommand{\prefix}[3]{#1?(#2) . #3}
\newcommand{\lift}[2]{#1 \lliftb #2 \rliftb}
\newcommand{\clift}[1]{\lliftb #1 \rliftb}
\newcommand{\quotep}[1]{\mathsf{@}#1}
\newcommand{\dropn}[1]{\mathsf{*}#1}
\newcommand{\procn}[1]{\stackrel{\vee}{x}}

\newcommand{\newp}[2]{(\newkw \; #1 ) #2}
\newcommand{\bangp}[1]{! #1}

\newcommand{\substp}[2]{\{ \quotep{#1} / \quotep{#2} \}}
\newcommand{\substn}[2]{\{ #1 / #2 \}}

\newcommand{\psubstp}[2]{\widehat{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\widehat{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{( #1 ) #2}
\newcommand{\annihilate}[1]{#1^{\times}}
\newcommand{\dualize}[1]{#1^{\bullet}}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}
\newcommand{\pmeaningof}[1]{\ldb #1 \rdb}
\newcommand{\nmeaningof}[1]{\lrbb #1 \rrbb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}

\newcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}
\newcommand{\vect}[1]{\stackrel{\rightharpoonup}{#1}}

\newcommand{\rhoc}{$\rho$-calculus}

\makeatletter
\gdef\tshortstack{\@ifnextchar[\@tshortstack{\@tshortstack[c]}}
\gdef\@tshortstack[#1]{%
  \leavevmode
  \vtop\bgroup
    \baselineskip-\p@\lineskip 3\p@
    \let\mb@l\hss\let\mb@r\hss
    \expandafter\let\csname mb@#1\endcsname\relax
    \let\\\@stackcr
    \@ishortstack}
\makeatother

\title{Rho by any other name}
\author{
Michael Stay\inst{1}\\
\and
L.G. Meredith\inst{2}\\
}
\institute{
  {Pyrofex Corp.}\\
  \email{\fontsize{8}{8}\selectfont stay@pyrofex.net}\\
  \and
  {RChain Cooperative}\\
  \email{\fontsize{8}{8}\selectfont greg@rchain.coop}
}
\begin{document}
\maketitle
\begin{abstract}
\noindent
  We show that graph-enriched Lawvere theories suffice to faithfully
  model concurrent combinators for mobile concurrent processes. In a
  manner akin to abstraction elimination which transforms lambda terms
  into terms in Schönfinkel and Curry's SKI combinator calculus, which
  has no names, Yoshida's elimination algorithm for the asynch \pic
  produces a combinator calculus,
  but still uses names and the $\mathsf{new}$ operator to introduce
  them, as well as replication.  We show that Meredith and Radestock's
  reflection technique allows
  us to give a name-free higher-order concurrent combinator calculus
  that captures the full behavior of the rho-calculus, and thus the
  \pic, without any dependency on names, the $\mathsf{new}$ operator,
  or replication. The resulting combinator calculus has a natural
  presentation in graph-enriched Lawvere theories, which faithfully
  capture its operational semantics.

\end{abstract}

\section{Introduction}
  
  Lawvere theories enriched over category-like structures like graphs or posets provide a 
provide a nice framework for term rewriting \cite{GhaniLuth}: the underlying Lawvere theory provides an algebraic signature for the syntax of terms, while the enrichment provides structure for encoding the reduction relation on the terms.
% N. Ghani, C. Lüth, Monads and modular term rewriting, in: Proc. CTCS ’97, Lecture Notes in Computer Science, Vol. 1290, Springer, Berlin, 1997, pp. 69–86.

  Many term calculi, like lambda calculus or pi calculus, involve binders for names, and the mathematics of bound variable names is subtle.  Sch\"onfinkel
introduced the SKI combinator calculus in 1924 to clarify the role of
quantified variables in intuitionistic logic by eliminating them
\cite{finkel}; Curry developed Sch\"onfinkel's ideas much further.  The recent
work by Jamie Gabbay and Andrew Pitts
\cite{DBLP:journals/fac/GabbayP02} and others
\cite{DBLP:journals/jcss/Clouston14} on nominal set theory has put the
study of bound names and substitution on a much nicer foundation, but
there is still value in eliminating bound variables because of the
clear connection between combinators and logical axioms.  As
concurrency becomes more important to the practice of computer science, it is worth
attempting to eliminate bound variables or names to study the
resulting logics.

  The {\pic} (\cite{milner91polyadicpi}) has two binders for names: the $\nu$ operator, which introduces a new name into scope, and the input prefix, which introduces a name for labeling locations for substitution.  Yoshida \cite{DBLP:journals/tcs/Yoshida02} describes an elimination algorithm that gets rid of input prefixes, but not the $\nu$ operator.  Meredith and Radestock \cite{DBLP:journals/entcs/MeredithR05} introduce reflective operators into a higher-order pi calculus and implment $\nu$ and replication in terms of reflection.  Here, we present a fusion of those ideas: a name-free concurrent combinator calculus into which Yoshida's combinators have a faithful embedding.  The operational semantics of the resulting calculus can be presented using a Lawvere theory enriched over graphs.

\section{A reflective higher-order concurrent combinator calculus}

\subsection{Yoshida's original combinator calculus}

\begin{mathpar}
  \inferrule* [lab=atom] {} { P \bc m(a,b) \;|\; d(a,b,c) \;|\; k(a) \;|\; fw(a,b) \;|\; br(a,b) \;|\; bl(a,b) \;|\; s(a,b,c) }
  \and
  \inferrule* [lab=process] {} {\bm \; (\mathsf{new}\; a)P \;|\; P|P \;|\; !P}
\end{mathpar}

As in the {\pic}, the $\mathsf{new}$ operator is a binding operator
for names. Thus, we have a notion of free and bound names.

\begin{mathpar}
  \freenames{\pzero} := \emptyset
  \and
  \freenames{k(a)} := \{ a \}
  \and
  \freenames{m(a,b)} = \freenames{f(a,b)} = \freenames{br(a,b)} = \freenames{bl(a,b)} := \{ a, b \}
  \and
  \freenames{d(a,b,c)} = \freenames{s(a,b,c)} := \{ a, b, c \}
  \and
  \freenames{(\mathsf{new}\;a)P} := \freenames{P} \setminus \{ a \}
  \and
  \freenames{P|Q} := \freenames{P} \cup \freenames{Q}
  \and
  \freenames{!P} := \freenames{P}
\end{mathpar}

The bound names of a process, $\boundnames{P}$, are those names occurring in $P$
that are not free. For example, in $(\mathsf{new}\; b)m(a,b)$, the name $a$ is free, while $b$ is bound.

\begin{definition}
Then two processes, $P,Q$, are alpha-equivalent if $P = Q\{\vec{y}/\vec{x}\}$ for
some $\vec{x} \in \boundnames{Q},\vec{y} \in \boundnames{P}$, where $Q\{\vec{y}/\vec{x}\}$
denotes the capture-avoiding substitution of $\vec{y}$ for $\vec{x}$ in $Q$.
\end{definition}

\begin{definition}
  The {\em structural congruence} \cite{SangiorgiWalker} , $\equiv$,
  between processes is the least congruence containing
  alpha-equivalence, satisfying the abelian monoid laws
  (associativity, commutativity and $\pzero$ as identity) for parallel
  composition $|$.
\end{definition}

Rewrite rules
\[\begin{array}{rl}
  d(abc) | m(ax) & \red m(bx) | m(cx) \\
  k(a) | m(ax) & \red 0 \\
  fw(ab) | m(ax) & \red m(bx) \\
\end{array} \quad \quad
\begin{array}{rl}
  br(ab) | m(ax) & \red fw(bx) \\
  bl(ab) | m(ax) & \red fw(xb) \\
  s(abc) | m(ax) & \red fw(bc)
\end{array}\]
\[\begin{array}{rl}
  !P & \red P|!P \\
\end{array}\]
\begin{mathpar}
  \inferrule* {{P} \red {P}'} {{{P} | {Q}} \red {{P}' | {Q}}}
  \and
  \inferrule* {{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}
\end{mathpar}

\subsection{RHO combinator calculus}
  The {\pic} is not a closed theory, but
rather a theory dependent upon some theory of names. Taking an
operational view, one may think of the {\pic} as a procedure that when
handed a theory of names provides a theory of processes that
communicate over those names. This openness of the theory has been
exploited in {\pic} implementations, like the execution engine in
Microsoft's Biztalk \cite{biztalk}, where an ancillary binding
language providing a means of specifying a `theory' of names; {\em e.g.},
names may be TCP/IP ports, or URLs, or object references, {\em etc.}  But
foundationally, one might ask if there is a closed theory of
processes, {\em i.e.} one in which the theory of names arises from and is
wholly determined by the theory of processes. Behind this question
lurk a whole host of other exciting and potentially enlightening
questions regarding the role of names with structure in calculi of
interaction and the relationship between the structure of names and
the structure of processes.

We remove new names and replication and introduce quoting/unquoting
operators, then allow processes in the second argument of a send and introduce an extra rewrite governing the interaction between sending and unquoting.

\begin{mathpar}
  \inferrule* [lab=atom] {} { P \bc m(a,P) \;|\; d(a,b,c) \;|\; k(a) \;|\; fw(a,b) \;|\; br(a,b) \;|\; bl(a,b) \;|\; s(a,b,c) }
  \and
  \inferrule* [lab=process] {} {\bm \; *a \;|\; P|P}
  \and
  \inferrule* [lab=nominal] {} {a \bc \quotep{P}}
\end{mathpar}

Rewrite rules
\[\begin{array}{rl}
  d(abc) | m(aP) & \red m(bP) | m(cP) \\
  k(a) | m(aP) & \red 0 \\
  fw(ab) | m(aP) & \red m(bP) \\
\end{array} \quad \quad
\begin{array}{rl}
  br(ab) | m(aP) & \red fw(b@P) \\
  bl(ab) | m(aP) & \red fw(@Pb) \\
  s(abc) | m(aP) & \red fw(bc) \\
  *a     | m(aP) & \red P
\end{array}\]
\begin{mathpar}
  \inferrule* {{P} \red {P}'} {{{P} | {Q}} \red {{P}' | {Q}}}
  \and
  \inferrule* {{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}
\end{mathpar}

\subsubsection{Implementing new names with reflection}

The translation will be given by a function, $\meaningof{-}( -, - ) :
\Proc_{\pi} \times \QProc \times \QProc \red \Proc$. The guiding
intuition is that we construct alongside the process a distributed memory
allocator, the process' access to which is mediated through the second argument
to the function. The first argument determines the shape of the memory
for the given allocator.

Given a process, $P$, we pick $n$ and $p$ such that $n \neq p$ and
distinct from the free names of $P$. For example, $n = \quotep{\Pi_{m
\in \freenames{P}}\outputp{m}{\quotep{\pzero}}}$ and $p =
\quotep{\Pi_{m \in
\freenames{P}}\prefix{m}{\quotep{\pzero}}{\pzero}}$. Then

\begin{equation*}
	\meaningof{P} = \meaningof{P}_{2nd}( n, p )
\end{equation*}

where

\begin{eqnarray*}
   	\meaningof{\pzero}_{2nd} (  n, p )
   		& = &
   		 \pzero \\
   	\meaningof{x \id{[} y \id{]}}_{2nd} (  n, p ) 
  		& = & 
  		x \id{[} y \id{]} \\
   	\meaningof{x \id{(} y \id{)} \concat P}_{2nd} (  n, p ) 
   		& = & 
 		x \id{(} y \id{)} \concat \meaningof{P}_{2nd} (  n, p ) \\
   	\meaningof{P \juxtap Q}_{2nd} (  n, p ) 
   		& = & 
 		\meaningof{P}_{2nd} ( n^{l}, p^{l} )
   			 \juxtap \meaningof{Q}_{2nd} ( n^{r}, p^{r} ) \\
%    	\meaningof{\id{!} P}_{2nd} (  n, p )
%    		& = & \binpar{\lift{x}{\binpar{upn( n^{lr}, p^{lr}, n^{rl}, p^{rl} )}
% 						      {\meaningof{P}_{3rd}( n^{lr}, p^{lr}, n^{rl}, p^{rl} )}}}
% 		             {\binpar{D(x)}{\binpar{\outputp{n^{lr}}{n}}{\outputp{p^{lr}}{p}}}} \\
   	\meaningof{\id{!} P}_{2nd} (  n, p )
   		& = & \binpar{\lift{x}{\meaningof{P}_{3rd}( n^{r}, p^{r} )}}
		             {\binpar{D(x)}{\binpar{\outputp{n^{r}}{n^{l}}}{\outputp{p^{r}}{p^{l}}}}} \\
   	\meaningof{\id{(}\nu \; x \id{)} P}_{2nd} (  n, p ) 
   		& = & 
 		\prefix{p}{x}{\binpar{\meaningof{P}_{2nd} ( n^{l}, p^{l} )}{\outputp{p}{n}}} \\
\end{eqnarray*}

and

\begin{eqnarray*}
	x^{l} & \triangleq & \quotep{\outputp{x}{x}} \\
	x^{r} & \triangleq & \quotep{\prefix{x}{x}{\pzero}} \\
	\meaningof{P}_{3rd}( n'', p'' ) 
		& \triangleq & 
			\prefix{n''}{n}{\prefix{p''}{p}{(\binpar{\meaningof{P}_{2nd}(  n, p )}
							        {(\binpar{D(x)}{\binpar{\outputp{n''}{n^{l}}}{\outputp{p''}{p^{l}}}})})}} \\
\end{eqnarray*}

	Note that all $\nu$-binding is now interpreted, as in Wischik's
	global $\pi$-calculus, as an input guard \cite{globalpi}.
	
	It is also noteworthy that the translation is dependent on how
	the parallel compositions in a process are
	associated. Different associations will result in different
	bindings for $\nu$-ed names. This will not result in different
	behavior, however, as the bindings will be consistent
	throughout the translation of the process.

	$P \wbbisim_{\pi} Q \iff \ldb P \rdb \wbbisim_{r(\texttt{FN}(P))} \ldb Q \rdb$.

\subsubsection{Implementing replication with reflection}

As mentioned before, it is known that replication (and hence
recursion) can be implemented in a higher-order process algebra
\cite{SangiorgiWalker}. As our first example of calculation with the
machinery thus far presented we give the construction explicitly in
the {\rhoc}.

\begin{eqnarray}
	D_{x} & := & \prefix{x}{y}{(\binpar{\outputp{x}{y}}{\dropn{y}})} \nonumber\\
	\bangp_{x}{P} & := & \binpar{\lift{x}{\binpar{D_{x}}{P}}}{D_{x}} \nonumber
\end{eqnarray}

\begin{eqnarray}
	\bangp_{x}{P} & & \nonumber\\
	=
	& \lift{x}{(\prefix{x}{y}{(\outputp{x}{y} | \dropn{y})) | P}} 
	      | \prefix{x}{y}{(\outputp{x}{y} | \dropn{y})} & \nonumber\\
	\red
	& (\outputp{x}{y} | \dropn{y})\substn{\quotep{(\prefix{x}{y}{(\dropn{y} | \outputp{x}{y})) | P}}}{y} & \nonumber\\
	=
	& \outputp{x}{\quotep{(\prefix{x}{y}{(\outputp{x}{y} | \dropn{y})) | P}}}
	  | {(\prefix{x}{y}{(\outputp{x}{y} | \dropn{y})) | P}} & \nonumber\\
	\red
	& \ldots & \nonumber\\
	\red^*
	& P | P | \ldots & \nonumber
\end{eqnarray}

Of course, this encoding, as an implementation, runs away, unfolding
$\bangp{P}$ eagerly. A lazier and more implementable replication
operator, restricted to input-guarded processes, may be obtained as follows.

\begin{eqnarray}
\bangp{\prefix{u}{v}{P}} 
	:= 
	\binpar{\lift{x}{\prefix{u}{v}{(\binpar{D(x)}{P})}}}{D(x)} \nonumber
\end{eqnarray}

\begin{remark}
  Note that the lazier definition still does not deal with summation
  or mixed summation (i.e. sums over input and output). The reader is
  invited to construct definitions of replication that deal with these
  features. 

  Further, the definitions are parameterized in a name, $x$. Can you,
  gentle reader, make a definition that eliminates this parameter and
  guarantees no accidental interaction between the replication
  machinery and the process being replicated -- i.e. no accidental
  sharing of names used by the process to get its work done and the
  name(s) used by the replication to effect copying. This latter
  revision of the definition of replication is crucial to obtaining
  the expected identity $!!P \sim !P$.
\end{remark}

\begin{remark}\label{rem:paradoxical_combinator}
  The reader familiar with the lambda calculus will have noticed the
  similarity between $D$ and the paradoxical combinator.

  [Ed. note: the existence of this seems to suggest we have to be more
  restrictive on the set of processes and names we admit if we are to
  support no-cloning.]
\end{remark}

\section{Gph-enriched categories}
Here we review standard results in enriched category theory; see \cite{CIS-335497}, \cite{Power99EnrichedLawvereTheories}, \cite{DBLP:journals/acs/LackR11}, and \cite{Trimble} for more details.

A {\bf directed multigraph}, hereafter {\bf graph}, consists of a set $E$ of edges, a set $V$ of vertices, and two functions $s,t\maps E \to V$ picking out the source and target of each edge.  There are no constraints on $E, V, s,$ or $t$, so a graph may have infinitely many vertices, infinitely many edges between any two vertices, and loops.  A {\bf graph homomorphism} from $(E, V, s, t)$ to $(E', V', s', t')$ is a pair of functions $(\epsilon\maps E \to E', \upsilon\maps V \to V')$ such that $\upsilon\circ s = s' \circ \epsilon$ and $\upsilon\circ t = t' \circ \epsilon$.  {\bf Gph} is the category of graphs and graph homomorphisms.  Gph has finite products: the terminal graph is the graph with one vertex and one loop, while the product of two graphs $(E, V, s, t) \times (E', V', s', t')$ is $(E \times E', V \times V', s \times s', t\times t').$

A {\bf Gph-enriched category} is a category where each hom set $\hom(x,y)$ is equipped with a set $E_{x,y}$ and functions $s_{x,y}, t_{x,y}\maps E_{x,y} \to \hom(x,y);$ that is, each hom set is thought of as a set of vertices and is equipped with a set of edges making it into a graph.  A Gph-enriched category has finite products if the underlying category does.

Any category is trivially Gph-enriched by taking the all the sets of edges to be empty.  Given two graph homomorphisms $F, G\maps (E, V, s, t) \to (E', V', s', t'),$ a {\bf graph shift} assigns to each vertex $v$ in $V$ an edge $e'$ in $E'$ such that $s'(e') = F(v)$ and $t'(e') = G(v).$  The category Gph is nontrivially Gph-enriched, making it a cartesian closed category: the objects are graphs, and for any pair of graphs $(G, G')$ we get a graph whose vertices are graph homomorphisms from $G$ to $G'$ and whose edges are graph shifts.

A {\bf Gph-enriched functor} between two Gph-enriched categories $C, D$ is a functor between the underlying categories such that the graph structure on each hom set is preserved, {\em i.e.} the functions between hom sets are graph homomorphisms between the hom graphs.

Let $S$ be a finite set, $\FinSet$ be a skeleton of the category of finite sets and functions between them, and $\FinSet/S$ be the category of functions into $S$ and commuting triangles.  A {\bf multisorted Gph-enriched Lawvere theory}, hereafter {\bf Gph-theory} is a Gph-enriched category with finite products Th equipped with a finite set $S$ of {\bf sorts} and a Gph-enriched functor $\theta\maps \FinSet^{\op}/S \to \Th$ that preserves products strictly.  Any Gph-theory has an underlying multisorted Lawvere theory given by forgetting the edges of each hom graph.

A {\bf model} of a Gph-theory Th is a Gph-enriched functor from Th to Gph that preserves products up to natural isomorphism.  A {\bf homomorphism of models} is a braided Gph-enriched natural transformation between the functors.  Let FPGphCat be the 2-category of small Gph-enriched categories with finite products, product-preserving Gph-functors, and braided Gph-natural transformations.  The forgetful functor $U\maps \FPGphCat[\Th, \Gph] \to \Gph$ that picks out the underlying graph of a model has a left adjoint $L$ that picks out the free model on a graph.

\section{Gph-theories as models of computation}

Lawvere theories and their generalizations are categories with infinitely many objects and morphisms, but most theories of interest are finitely generated.  A presentation of underlying multisorted Lawvere theory of a finitely-generated Gph-theory is a signature for a term calculus, consisting of a set of sorts and a set of term constructors, while the edges in the hom graphs of the theory encode the reduction relation.  It is straightforward to verify that Gph-theories suffice to capture the operational semantics of any calculus where every context is a reduction context.

Here is a presentation of the SKI combinator calculus as a Gph-theory:
\begin{itemize}
  \item one sort $T$, for terms
  \item term constructors
  \[\begin{array}{rl}
    S&:1 \to T\\
    K&:1 \to T\\
    I&:1 \to T\\
    (-\; -)&: T^2 \to T\\
  \end{array}\]
  \item rewrites
  \[\begin{array}{rl}
    \sigma&:(((S\; x)\; y)\; z) \Rightarrow ((x\; z)\; (y\; z))\\
    \kappa&:((K\; y)\; z) \Rightarrow y\\
    \iota&:(I\; z) \Rightarrow z\\
  \end{array}\]
\end{itemize}
where in the rewrites we have used expressions like $((K\; y)\; z)$ as shorthand for
\[ T\times T \xrightarrow{\tiny\mbox{left}^{-1}} 1\times T \times T \xrightarrow{K \times T \times T} T\times T \times T \xrightarrow{(-\;-)\times T} T\times T \xrightarrow{(-\;-)} T. \]

A model $M$ of this Gph-theory in Gph picks out a graph $M(T)$ of terms and rewrites.  It picks out three special vertices $S,K,$ and $I$ of $M(T)$; it equips $M(T)$ with a graph homomorphism from $M(T)^2$ to $M(T)$ that says for every pair of vertices $(u,v),$ there is a vertex $(u\;v)$, and similarly for edges; and it equips $M(T)$ with graph shifts asserting the existence of an edge out of a reducible expression to the term it reduces to.

That this Gph-theory captures the semantics of the SKI calculus is almost definitional: there is an edge in $M(T)$ precisely when the source vertex is reducible to the target vertex.  

\section{Gph-theory for the RHO combinators}
The RHO combinators above also have a presentation as a Gph-theory:
\begin{itemize}
  \item Sorts $N, T$
  \item Term constructors
    \[\begin{array}{rl}
      k &: N \to T \\
      m &: N \times T \to T \\
      fw,br,bl &: N^2 \to T \\
      s &: N^3 \to T \\
    \end{array} \quad \quad
    \begin{array}{rl}
      | &: T^2 \to T \\
      * &: N \to T \\
      @ &: T \to N \\
    \end{array}\]
  \item Rewrite rules
    \[\begin{array}{rl}
      d(abc) | m(aP) & \Rightarrow m(bP) | m(cP) \\
      k(a) | m(aP) & \Rightarrow 0 \\
      fw(ab) | m(aP) & \Rightarrow m(bP) \\
      br(ab) | m(aP) & \Rightarrow fw(b@(P)) \\
      bl(ab) | m(aP) & \Rightarrow fw(@(P)b) \\
    \end{array} \quad \quad
    \begin{array}{rl}
      s(abc) | m(aP) & \Rightarrow fw(bc) \\
      *a | m(aP) & \Rightarrow P \\
      *(@P) & \Rightarrow P \\
      P | Q & \Leftrightarrow Q | P \\
      ((P | Q) | R) & \Leftrightarrow (P | (Q | R)) \\
    \end{array}\]
\end{itemize}







\section{Faithfulness of embedding Yoshida's combinators into RHO combinators}

\section{Conclusion and future work}
TBD

\bibliographystyle{amsplain}
\bibliography{rhocomb}
\end{document}
