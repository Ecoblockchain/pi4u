\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{stmaryrd}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\maps}{\colon}
\newcommand{\FinSet}{\mathrm{FinSet}}
\newcommand{\Set}{\mathrm{Set}}
\newcommand{\Cat}{\mathrm{Cat}}
\newcommand{\Mach}{\mathrm{Mach}}
\newcommand{\Mon}{\mathrm{Mon}}
\newcommand{\BoolAlg}{\mathrm{BoolAlg}}
\newcommand{\Form}{\mathrm{Form}}
\renewcommand{\left}{\mathrm{left}}
\renewcommand{\right}{\mathrm{right}}
\newcommand{\op}{\mathrm{op}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\lhom}{\Rightarrow}

\title{Logic as a distributive law}
\author{
Michael Stay\\
  {Pyrofex Corp.}\\
  {\fontsize{8}{8}\selectfont stay@pyrofex.net}
\and
L.G. Meredith\\
  {Biosimilarity, LLC}\\
  {\fontsize{8}{8}\selectfont lgreg.meredith@biosimilarity.com}
}
\begin{document}
\maketitle
\begin{abstract}
\noindent
We present an algorithm that takes a formal presentation of a virtual machine---a Lawvere 2-theory---and outputs a spatial-behavioral type system.  The types are ``types \`a la Curry'' or in Reynolds' terminology, ``extrinsic'' types: they are propositions about machine state and behavior.  We interpret a formula as a collection of terms of the grammar that satisfy the formula, and we interpret proofs as morphisms of collections.  A distributive law forms the core of this interpretation.

In the simplest case, formulae and proofs are given by the sum of the 2-theory Th(Mach) for the machine with the 2-theory Th(BoolAlg) for the Boolean algebra of subsets of states.  Since each 2-theory Th(X) corresponds to a finitary 2-monad X, the interpretation of formulae is a natural transformation from Mach+BoolAlg to BoolAlg$\circ$Mach built from the unit and multiplication transformations from the monads and an extra distributive law natural transformation 
\[\delta\maps \mathrm{Mach}\circ\mathrm{BoolAlg} \Rightarrow \mathrm{BoolAlg}\circ\mathrm{Mach}.\]

We present several examples of the logics so generated and some interesting formulae in those logics.
\end{abstract}

\section{Introduction}
[[ Expand this. ]]
  We present an algorithm that takes a formal presentation of a virtual machine and outputs a spatial-behavioral type system.  The presentation consists of a context-free grammar for the state of the machine together with a set of rewrite rules describing how the state changes---in category-theoretic terminology, a Lawvere 2-theory.  The types are ``types \`a la Curry'' or in Reynolds' terminology, ``extrinsic'' types: they are propositions about machine state and behavior.  We interpret a formula as a collection of terms of the grammar that satisfy the formula, and we interpret proofs as morphisms of collections.  A distributive law forms the core of this interpretation.

  In the simplest case, formulae and proofs are given by the sum of the 2-theory Th(Mach) for the machine with the 2-theory Th(BoolAlg) for the Boolean algebra of subsets of states.  Since each 2-theory Th(X) corresponds to a finitary 2-monad X, the interpretation of formulae is a natural transformation from Mach+BoolAlg to BoolAlg$\circ$Mach built from the unit and multiplication transformations from the monads and an extra distributive law natural transformation 
  \[\delta\maps \mathrm{Mach}\circ\mathrm{BoolAlg} \Rightarrow \mathrm{BoolAlg}\circ\mathrm{Mach}.\]

  We present several examples of the logics so generated and some interesting formulae in those logics.

\subsection{A motivating example}

Rather than dive into the full 2-categorical machinery right away, we will start with a 1-categorical example, the logic for the language of monoids.

Let FinSet be a skeleton of the category of finite sets.  The {\bf Lawvere theory} of a machine is a category Th(Mach) with finite products equipped with an identity-on-objects functor $\theta\maps \FinSet^\op \to \mathrm{Th(Mach)}.$  The objects of category Th(Mach) are therefore products of a generating object $S,$ the {\bf sort}.  The morphisms of Th(Mach) are generated by a set of morphisms from finite powers of $S$ to $S$ by products and composition, so a Lawvere theory may be presented as a set of {\bf term constructors}
\[ f_i\maps S^{n_i} \to S, \]
together with a set of equations, where $i$ ranges over some index set $I$ and $n_i \in \NN$.  The {\bf arity} of $f_i$ is $n_i.$

A product-preserving functor from Th(Mach) to Set picks out a set and equips it with structure maps satisfying the equations.  The category Prod(Th(Mach), Set) of product-preserving functors and natural transformations between them is equivalent to the category Mach of machines and machine homomorphisms.  There is a forgetful functor ${U\maps \Mach \to \Set}$ that forgets the extra structure.  The functor $U$ has a left adjoint ${L\maps \Set \to \Mach}$ that picks out the free machine on a set of base states.  The monad $\Mach = UL\maps \Set \to \Set$ picks out the underlying set $ULX$ of the free machine $LX$ on a set $X$.  Lawvere theories are in bijection with finitary monads; the qualifier ``finitary'' means that each term constructor has a finite arity.

Here is a presentation of the ``Lawvere theory of a monoid'' Th(Mon):\\
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $\cdot \circ (S \times \cdot) = \cdot \circ (\cdot \times S)$ (associativity)
      \item $\cdot \circ (e \times S) \circ \left^{-1} = S$ (left unit)
      \item $\cdot \circ (S \times e) \circ \right^{-1} = S$ (right unit)        
    \end{itemize}
  \end{itemize}
\end{center}
where ${\left\maps 1 \times S \stackrel{\sim}{\to} S}$ and ${\right\maps S \times 1 \stackrel{\sim}{\to} S}$ are the canonical isomorphisms.

An implementation of this specification will assign a set of values to the sort and functions to the term constructors such that the equations are satisfied; the category of product-preserving functors from Th(Mon) to Set and natural transformations between them is equivalent to the category of monoids and monoid homomorphisms.  There is a forgetful functor $U\maps \Mon \to \Set$ that forgets the multiplication and unit, and outputs the underlying set of elements.  The functor $U$ has a left adjoint $L\maps \Set \to \Mon$ that outputs the free monoid on a set.  The composite functor $\Mon = UL\maps \Set \to \Set$ is the corresponding monad.

All our formulae about monoids will denote subsets of the elements of the monoid; we use Th(BoolAlg) to describe them. [[ Note here or below about the model: it's not all subsets, it's just the constructible ones, so we're automatically complete. ]]
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $\land\maps S^2 \to S$
      \item $\lor\maps S^2 \to S$
      \item $\top\maps 1 \to S$
      \item $\bot\maps 1 \to S$
      \item $\neg\maps S \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item associativity, commutativity and unit laws for $\land$ and $\lor$
      \item distributivity of $\land$ over $\lor$
      \item involution for $\neg$
      \item de Morgan's laws
    \end{itemize}
  \end{itemize}
\end{center}
From this theory, we can derive the monad BoolAlg for the free Boolean algebra on a set.

The sum of the two theories above is a new theory Th(Form) = Th(Mon) + Th(BoolAlg) whose terms are our formulae.  Th(Form) is presented by identifying the sorts and taking the union of the term constructors and the union of the equations.
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
      \item $\land\maps S^2 \to S$
      \item $\lor\maps S^2 \to S$
      \item $\top\maps 1 \to S$
      \item $\bot\maps 1 \to S$
      \item $\neg\maps S \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item associativity and unit laws for $\cdot$
      \item associativity, commutativity, and unit laws for $\land$ and $\lor$
      \item involution for $\neg$
      \item de Morgan's laws
    \end{itemize}
  \end{itemize}
\end{center}
The process of deriving a monad from a theory preserves sums.  Since the sum of two monads is the free product of the two, a general formula will be a term in an alternating composition of the two monads.  For example, suppose that $a, b, c, d \in X;$ then one formula is
\[ (({a}\lor{(b \cdot d)}) \cdot ({c}\lor{d})), \]
which is a term in Mon(BoolAlg(Mon($X$))).  The interpretation of this formula should be the set of monoid elements
\[ \{ ac, ad, bdc, bdd \}, \]
or in other words, the term
\[ (a \cdot c) \lor (a \cdot d) \lor ((b \cdot d) \cdot c) \lor ((b \cdot d) \cdot d) \]
in BoolAlg(Mon(X)).

In order to move all the uses of Mon to the right of the uses of BoolAlg, we need a distributive law natural transformation
\[ \delta\maps \Mon \circ \BoolAlg \Rightarrow \BoolAlg \circ \Mon. \]
Given $\delta$ and the monad units and multiplications, we can define an interpretation natural transformation
\[ \interp{-}\maps \Form\Rightarrow \BoolAlg \circ \Mon \]
in the obvious way.  Below, we write subsets of Mon($X$) using set notation:
\begin{align*}
  \interp{\top}_X &= \Mon(X)\\
  \interp{\bot}_X &= \emptyset\\
  \interp{{A}\lor{B}}_X &= \interp{A}_X \cup \interp{B}_X\\
  \interp{{A}\land{B}}_X &= \interp{A}_X \cap \interp{B}_X\\
  \interp{\neg A}_X &= \Mon(X) - \interp{A}_X\\
  \interp{{A} \cdot {B}} &= \Mon(\cdot)(\interp{A} \times \interp{B})\\
  \interp{e} &= \{e\}\\
  \interp{x \in X}_X &= \{x\}
\end{align*}

Even in this simple example, we have nontrivial formulae; for example,
\[ prime = \neg e \land \neg(\neg e \cdot \neg e) \]
is a 1-line formula for primality.  It is easy to verify that $\interp{prime}_X = X.$

\subsection{Moving to 2-categories}

In a computational context, when a data structure has some symmetry we do not care about, we often test two instances of the structure for equality by computing a normal form for each instance and then comparing the normal forms.  Monoids are associative, but we can imagine storing words of a monoid as binary trees internally and then comparing them by computing a normal form.  For the case of a normal form for the trees, we can eliminate 1 in a product by rewriting $(1 \cdot x)$ and $(x \cdot 1)$ to $x$, and we can shift all the parentheses to the right by rewriting $((x \cdot y) \cdot z)$ to $(x \cdot (y \cdot z)).$

The Lawvere 2-theory Th(Mon) of an unnormalized monoid is much the same as the 1-theory, except for the weakening of some equations to rewrites and the addition of new equations between the rewrites.

\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $a\maps \cdot \circ (S \times \cdot) \Rightarrow \cdot \circ (\cdot \times S)$
      \item $l\maps \cdot \circ (e \times S) \circ \left \Rightarrow S$
      \item $r\maps \cdot \circ (S \times e) \circ \right \Rightarrow S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $a \circ a = (S \times a) \circ a \circ (a \times S)$ (pentagon equation)
      \item $r \times S = (S \times l) \circ a$ (triangle equation)
    \end{itemize}
  \end{itemize}
\end{center}
From Th(Mon) we can derive a 2-monad Mon that essentially produces the free monoid on a set, but keeps track of the ``internal representation'' of the monoid---a binary tree---and accounts for the work needed to convert the internal representation to its normal form.  From this perspective, we can think of the trees as programs for a simple virtual machine and the process of normalization as the execution of the program.  Later in the paper, we will examine the case of the SKI combinator calculus, a Turing-complete programming language that was a predecessor to the lambda calculus; it, too, uses binary trees as programs, and execution of the program is a normalization process.

When we add the 2-monad BoolAlg to Mon, we get formulae like $(1 \cdot \top)$ denoting the set of trees whose leftmost child is the identity; because Mon is a 2-monad, we also get proofs like 
\[ ((r \circ l) \lor y)\maps ((e \cdot (x \cdot e)) \lor y) \to (x \lor y) \]
whose interpretations are homomorphisms of Boolean algebras.

The formulae in these examples have been propositions about the structure of terms.  Later in the paper, we will also show how to add modal operators that are propositions about the behavior of terms.

\section{Related work}
[[ Curry-Howard related work? ]]
[[ Lots of stuff on Lawvere theories and generalizations.  

- Lawvere, Functorial Semantics of Algebraic Theories

The original insight.

- Hyland \& Power, ``The Category Theoretic Understanding of Universal Algebra: Lawvere Theories and Monads''

  Lawvere theories and monads have been the two main category theoretic formulations of universal algebra, Lawvere theories arising in 1963 and the connection with monads being established a few years later. Monads, although mathematically the less direct and less malleable formulation, rapidly gained precedence. A generation later, the definition of monad began to appear extensively in theoretical computer science in order to model computational effects, without reference to universal algebra. But since then, the relevance of universal algebra to computational effects has been recognised, leading to renewed prominence of the notion of Lawvere theory, now in a computational setting. This development has formed a major part of Gordon Plotkin’s mature work, and we study its history here, in particular asking why Lawvere theories were eclipsed by monads in the 1960’s, and how the renewed interest in them in a computer science setting might develop in future.

- Lack \& Rosick\'y, ``Notions of Lawvere theory''

  Categorical universal algebra can be developed either using Lawvere theories (single-sorted finite product theories) or using monads, and the category of Lawvere theories is equivalent to the category of finitary monads on Set. We show how this equivalence, and the basic results of universal algebra, can be generalized in three ways: replacing Set by another category, working in an enriched setting, and by working with another class of limits than finite products.
  
- Trimble, ``multisorted Lawvere theories''

  Theorem 1. Let C be a category which admits general colimits and finite products that distribute over colimits. Then the forgetful functor ModC(Theta) to C\^Lambda is monadic.

- Lack \& Power, ``Lawvere 2-theories''

  http://www.mat.uc.pt/~categ/ct2007/slides/lack.pdf

- Power, ``Enriched Lawvere theories''

  We define the notion of enriched Lawvere theory, for enrichment over a monoidal biclosed category $V$ that is locally finitely presentable as a closed category. We prove that the category of enriched Lawvere theories is equivalent to the category of finitary monads on $V$. Moreover, the $V$-category of models of a Lawvere $V$-theory is equivalent to the $V$-category of algebras for the corresponding $V$-monad. This all extends routinely to local presentability with respect to any regular cardinal. We finally consider the special case where $V$ is $Cat$, and explain how the correspondence extends to pseudo maps of algebras.

- more
]]

\section{Categorical constructions}

\subsection{Multisorted Lawvere theories}
In the motivation section, each theory had only one sort; practical theories for virtual machines are usually multisorted.  Given a finite set of sorts $\Sigma,$ the category $\FinSet/\Sigma$ is the category whose objects are pairs $(S, s\maps S\to \Sigma),$ where $S$ is a finite set, and whose morphisms are morphisms $f\maps S \to S'$ such that the relevant triangle commutes.

A {\bf multisorted Lawvere theory} is a category Th(Mach) equipped with an identity-on-objects functor ${\theta\maps (\FinSet/\Sigma)^\op \to \mathrm{Th(Mach)}.}$  The category Prod(Th(Mach), Set) is equivalent to the category Mach of machines and machine homomorphisms.  There is a forgetful functor ${U\maps \Mach \to \Set^\Sigma}$ with a left adjoint ${L\maps \Set^\Sigma \to \Mach}$ that picks out the free machine on a $|\Sigma|$-tuple of sets.  The monad ${UL\maps \Set^\Sigma \to \Set^\Sigma}$ picks out the underlying $|\Sigma|$-tuple of sets $ULX$ of the free machine $LX$ on a $|\Sigma|$-tuple of sets $X$.

An example of a multisorted Lawvere theory is that of a group action on a set, which involves a choice of both a group $G$ and a set $V$ to act on.  The presentation of Th(GrpAct) has a pair of sorts $S = (G, V)$, all the term constructors and equations as the theory of a group (replacing $S$ by $G$), together with a new term constructor
\begin{itemize}
  \item $a\maps G \times V \to V$
\end{itemize}
and equations
\begin{itemize}
  \item $a \circ (e \times V) \circ \mathrm{left}_V = V$ (identity action)
  \item $a \circ (m \times V) = a \circ (G \times a)$ (compatibility).
\end{itemize}

Another example is the theory of a directed graph.
\begin{itemize}
  \item Sorts:
  \begin{itemize}
    \item $E$ for edges
    \item $V$ for vertices
  \end{itemize}
  \item Term constructors
  \begin{itemize}
    \item $s\maps E \to V$ for the source of an edge
    \item $t\maps E \to V$ for the target of an edge
  \end{itemize}
  \item No equations
\end{itemize}
The free graph on two sets $E$ and $V$ adjoins to $V$ a source and target vertex for each edge.

\subsection {Lawvere 2-theories}
In this paper, the {\bf multisorted Lawvere 2-theory} of a machine is a 2-category Th(Mach) equipped with an identity-on-objects functor $\theta\maps (\FinSet/\Sigma)^\op \to \mathrm{Th(Mach)},$ where we promote $(\FinSet/\Sigma)$ to a 2-category by adding identity 2-morphisms to every 1-morphism.  As noted in the related work section, other authors have considered much more powerful notions of 2-theory, but we will not need the extra features.  Our notion of a multisorted Lawvere 2-theory may be presented by a finite set of sorts, a set of term constructors with finite arity, a set of rewrites, and a set of equations between rewrites.  

Our models of multisorted Lawvere 2-theories are functors into $\Cat^\Sigma$ that preserve products up to isomorphism, not merely up to equivalence.  As with 1-theories, the 2-category of product-preserving functors from Th(Mach) to $\Cat^\Sigma$, natural transformations, and modifications is equivalent to the 2-category of machines, machine homomorphisms, and machine transformations.  [[ Get the details right on just what kind of strictness for machines, homs, and nts. ]] For a functor $F$ to preserve products means that it is equipped with a natural equivalence between $F(T^n)$ and $F(T)^n.$

The ``free pointed magma on a set equipped with normalization'' from the introduction is an example of a single-sorted Lawvere 2-theory; another example of a single-sorted Lawvere 2-theory is the theory of the SKI combinator calculus.  Th(SKI) has a presentation
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $T$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $S\maps 1 \to T$
      \item $K\maps 1 \to T$
      \item $I\maps 1 \to T$
      \item $(-\;-)\maps T^2 \to T,$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $\forall x,y,z \in T, \quad \sigma \maps (((S\; x)\; y)\; z) \Rightarrow ((x\; z)\; (y\; z))$
      \item $\forall y,z \in T, \quad \kappa \maps ((K\; y)\; z) \Rightarrow y$
      \item $\forall z \in T, \quad \iota \maps (I\; z) \Rightarrow z$
    \end{itemize}
    \item No equations.
  \end{itemize}
\end{center}
The Church-Rosser theorem for the SKI calculus in this context says that any two terminating rewrites out of an SKI term have the same codomain; however, we do not usually want to impose equality on the rewrites, since they can differ greatly in computational complexity.  For example, suppose that we have the term $((K\; I)\; x),$ where $x$ is some term that takes a long time to reduce to its normal form; a rewrite that reduces $x$ first and then uses $\kappa$ takes much longer than just doing $\kappa$ first, though both rewrites begin and end at the same term.

The free model of Th(SKI) on a category takes its objects as terms and its morphisms as rewrites, then freely adjoins $S,K,$ and $I$ and all applications of one object to another, as well as new morphisms generated by $\sigma,\kappa,$ and $\iota.$  The free model on the empty category will contain only terms and rewrites from the SKI calculus.

Lawvere 2-theories encode nondeterminism by means of multiple possible rewrites between term constructors.  Here's a presentation of a toy theory Th(Lock) for acquiring a mutex.
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $T$ for terms
      \item $N$ for names
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $lock\maps 1 \to T$
      \item $request\maps N \to T$
      \item $acquired\maps N \to T$
      \item $|\maps T^2 \to T$
      \item $0 \maps 1 \to T$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $\forall x \in T, \quad u\maps 0|x \Rightarrow x$
      \item $\forall x,y \in T,\quad c\maps x|y \stackrel{\sim}{\Rightarrow} y|x$
      \item $\forall x,y,z \in T,\quad a\maps (x|y)|z \stackrel{\sim}{\Rightarrow} x|(y|z)$
      \item $\forall n \in N,\quad get\maps lock | request(n) \stackrel{\sim}{\Rightarrow} acquired(n)$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $u = T$ (| is unital)
      \item $c = T^2$ (| is commutative)
      \item $a = T^3$ (| is associative)
    \end{itemize}
  \end{itemize}
\end{center}
In the free model of this theory on $(T, N) = (\emptyset, \{ a,b\})$, there are two different non-identity rewrites out of
\[ lock \;|\; request(a) \;|\; request(b). \]
One rewrite is to
\[ acquired(a) \;|\; request(b), \]
and the other to
\[ request(a) \;|\; acquired(b). \]

\section{Categories of formulae and proofs}

Any 1-theory can be promoted to a 2-theory by turning each equation into a rewrite, then adding an equation asserting that the rewrite is equal to the identity rewrite.  Therefore as before, given a single-sorted Lawvere 2-theory Th(Mach), we get a 2-theory of formulae Th(Form) by adding the 2-theory of Boolean algebras Th(BoolAlg).  The models of Th(Form) are categories of formulae and proofs.

For multisorted Lawvere 2-theories, there is no canonical choice of sorts to identify between the theory of the machine and the theory of Boolean algebras, but in practical applications, there is often an obvious choice; for example, given the theory of a lock from the previous section, we probably want our formulae to talk about $T$ more than about $N$.  With that choice, the formula for those terms where the lock is available is $lock\;|\;\top,$ and $\neg(lock \;|\;\top)$ is the formula for those terms where the lock has been acquired.

\section{Interpretation}

[[ Thm: defining and as intersect, or as union, top as the whole set, bot as the empty set, neg as complement, and terms over collections as mapping the term constructor over the cartesian product of the collections is sound and complete. ]]

\section{Modal operators}

So far, all the examples of formulae have dealt with the structure of the term.  Far more interesting are sets of terms that all share some behavior.  For example, in the SKI calculus, we want to add the idea of an arrow type to our formulae, and have the interpretation of $A \lhom B$ be the subset of terms $t$ such that given a term $u\in\interp{A}$, the term $(t\; u)$ eventually evolves to a term $v\in\interp{B}.$

This notion of eventuality is an example of a modal operator.  Possibility is another, where possibility is to eventuality as ``there exists'' is to ``for all''.  Many interesting properties can be stated in terms of eventual and possible states, like
\begin{itemize}
  \item Security: it is not the case that my banking service will evolve to a state in which someone other than the bank and me has the ability to withdraw money from my account.
  \item Liveness: this process will always eventually handle another message.
  \item Termination: this computation will always halt.
  \item Structure: at the end of sorting, the data will be ordered.
\end{itemize}

To add a modal operator to a formula language, we first add it formally a term constructor to the term theory, then add the collection theory as before.  

To interpret the modal operator, we first interpret the formulae as above, then interpret modal terms as collections of terms, then use the join from the collection monad.

\subsection{Example: Arrow types in the SKI calculus}

The Lawvere 2-theory of the arrow type Th(Arrow) has one term constructor, no rewrites, and no equations.  The lack of rewrites and equations are because the arrow is a purely formal type, and it is only in our choice of semantics that it acquires its customary interpretation.
\begin{itemize}
  \item Sorts:
  \begin{itemize}
    \item $T$
  \end{itemize}
  \item Term constructors:
    \begin{itemize}
      \item $\lhom\maps T \to T$
    \end{itemize}
  \item No rewrites.
  \item No equations.
\end{itemize}

We get the theory of SKI with arrow Th(SKIArr) by adding Th(SKI) to Th(Arrow), and we get the theory of formulae Th(Form) by adding Th(SKIArr) to Th(BoolAlg).

To interpret terms from Th(Form), we compose the interpretation natural transformation above with another natural transformation $\alpha\maps \mathrm{SKIArr} \to \mathrm{BoolAlg} \circ \mathrm{SKI},$ followed by the join from the collection monad.  In particular, 
\begin{align*}
  \alpha(t) &= \begin{cases}
    \{ w | \exists \rho\maps (w\; u) \Rightarrow v \} & \text{if } t = u \lhom v\\
    \{ t \} & \text{otherwise.}
  \end{cases}
\end{align*}

[[ Thm.  Arrow extends to a profunctor. ]]

\subsection{The reflective higher-order pi calculus}



\end{document}