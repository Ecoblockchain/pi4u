\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{stmaryrd}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\maps}{\colon}
\newcommand{\FinSet}{\mathrm{FinSet}}
\newcommand{\Set}{\mathrm{Set}}
\newcommand{\Cat}{\mathrm{Cat}}
\newcommand{\Gad}{\mathrm{Gad}}
\newcommand{\Mon}{\mathrm{Mon}}
\newcommand{\BoolAlg}{\mathrm{BoolAlg}}
\newcommand{\Form}{\mathrm{Form}}
\renewcommand{\left}{\mathrm{left}}
\renewcommand{\right}{\mathrm{right}}
\newcommand{\op}{\mathrm{op}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\lhom}{\Rightarrow}

\title{Logic as a distributive law}
\author{
Michael Stay\\
  {Pyrofex Corp.}\\
  {\fontsize{8}{8}\selectfont stay@pyrofex.net}
\and
L.G. Meredith\\
  {Biosimilarity, LLC}\\
  {\fontsize{8}{8}\selectfont lgreg.meredith@biosimilarity.com}
}
\begin{document}
\maketitle
\begin{abstract}
\noindent
We present an algorithm that takes a formal presentation of a virtual machine and outputs a spatial-behavioral type system.  The presentation consists of a context-free grammar for the state of the machine together with a set of rewrite rules describing how the state changes---in category-theoretic terminology, a Lawvere 2-theory.  The types are ``types \`a la Curry'' or in Reynolds' terminology, ``extrinsic'' types: they are propositions about machine state and behavior.  We interpret a formula as a collection of terms of the grammar that satisfy the formula, and we interpret proofs as morphisms of collections.  A distributive law forms the core of this interpretation.

In the simplest case, formulae and proofs are given by the sum of the 2-theory $T$ for the machine with a 2-theory $C$ for a collection.  Since each 2-theory corresponds to a finitary 2-monad, the interpretation of formulae is a natural transformation from $T+C$ to $CT$ built from the unit and multiplication transformations and a distributive law natural transformation $\delta\maps TC \Rightarrow CT$.

We present several examples of the logics so generated and some interesting formulae in those logics.
\end{abstract}

\section{Introduction}
[[ Expand this. ]]
We present an algorithm that takes a formal presentation of a virtual machine and outputs a spatial-behavioral type system.  The presentation consists of a context-free grammar for the state of the machine together with a set of rewrite rules describing how the state changes---in category-theoretic terminology, a Lawvere 2-theory.  The types are ``types \`a la Curry'' or in Reynolds' terminology, ``extrinsic'' types: they are propositions about machine state and behavior.  We interpret a formula as a collection of terms of the grammar that satisfy the formula, and we interpret proofs as morphisms of collections.  A distributive law forms the core of this interpretation.

In the simplest case, formulae and proofs are given by the sum of the 2-theory $T$ for the machine with a 2-theory $C$ for a collection.  Since each 2-theory corresponds to a finitary 2-monad, the interpretation of formulae is a natural transformation from $T+C$ to $CT$ built from the unit and multiplication transformations and a distributive law natural transformation $\delta\maps TC \Rightarrow CT$.

We present several examples of the logics so generated and some interesting formulae in those logics.

\subsection{A motivating example}

Before considering the full 2-categorical machinery, it will be helpful to consider a 1-categorical example.

Consider this Java interface:
\begin{verbatim}
  interface Monoid<S> {
    S mult(S a, S b);
    S ident();
  }
\end{verbatim}
The interface, despite its name, only enforces the structure of a binary tree whose leaves are labeled by elements of $S$, and picks one element out as special; that is, it defines pointed magmas, not monoids.  In order to guarantee that implementations of the interface are monoids, we need to impose associativity and unit laws.  Java programmers typically rely on tests to give some assurance that implementations conform to the intended semantics.  Other programming languages, like Agda, require implementations to provide proofs.

In what follows, rather than use a Java interface, we will present the same information in a format slightly more amenable to typesetting.  Here is a presentation of the ``Lawvere theory of a monoid'' Th(Mon):\\
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Function symbols:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $\cdot \circ (S \times \cdot) = \cdot \circ (\cdot \times S)$ (associativity)
      \item $\cdot \circ (e \times S) \circ \left^{-1} = S$ (left unit)
      \item $\cdot \circ (S \times e) \circ \right^{-1} = S$ (right unit)        
    \end{itemize}
  \end{itemize}
\end{center}
where ${\left\maps 1 \times S \stackrel{\sim}{\to} S}$ and ${\right\maps S \times 1 \stackrel{\sim}{\to} S}$ are the canonical isomorphisms.

An implementation of this specification will assign a set of values to the sort and functions to the function symbols such that the equations are satisfied; that is, it will be a monoid, and all monoids arise in this manner.  As we will explain later, from this theory we can derive the monad Mon for the free monoid on a set.

To construct a logic where a formula, say $\phi$, denotes the collection of monoid words satisfying $\phi$, we need to specify what \emph{kind} of collection, because different kinds of collections have different constraints that affect how we construct them. For instance, lists are sensitive to order where sets are not. Bags are sensitive to multiplicity where sets are not.  In general, a collection is a ``shape'' in the sense of Someone \cite{someone}, labeled by elements of some set.

Since all our formulae about monoids will denote subsets of the elements of the monoid and subsets form a Boolean algebra, we can use Th(BoolAlg) to describe our collections. [[ Note here or below about the model: it's not all subsets, it's just the constructible ones. ]]
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Function symbols:
    \begin{itemize}
      \item $\land\maps S^2 \to S$
      \item $\lor\maps S^2 \to S$
      \item $\top\maps 1 \to S$
      \item $\bot\maps 1 \to S$
      \item $\neg\maps S \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item associativity, commutativity and unit laws for $\land$ and $\lor$
      \item distributivity of $\land$ over $\lor$
      \item involution for $\neg$
      \item de Morgan's laws
    \end{itemize}
  \end{itemize}
\end{center}
From this theory, we can derive the monad BoolAlg for the free Boolean algebra on a set.

The sum of the two monads above is a new monad Form = Mon + BoolAlg whose terms are our formulae.  The sum is presented by identifying the sorts and taking the union of the function symbols and the union of the equations.
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Function symbols:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
      \item $\land\maps S^2 \to S$
      \item $\lor\maps S^2 \to S$
      \item $\top\maps 1 \to S$
      \item $\bot\maps 1 \to S$
      \item $\neg\maps S \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item associativity and unit laws for $\cdot$
      \item associativity, commutativity, and unit laws for $\land$ and $\lor$
      \item involution for $\neg$
      \item de Morgan's laws
    \end{itemize}
  \end{itemize}
\end{center}
Since the sum of two monads is the free product of the two, a general formula will be a term in an alternating composition of the two monads.  For example, suppose that $a, b, c, d \in X;$ then one formula is
\[ (({a}\lor{(b \cdot d)}) \cdot ({c}\lor{d})), \]
which is a term in Mon(BoolAlg(Mon($X$))).  The interpretation of this formula should be the set of monoid elements
\[ \{ ac, ad, bdc, bdd \}, \]
or in other words, the term
\[ (a \cdot c) \lor (a \cdot d) \lor ((b \cdot d) \cdot c) \lor ((b \cdot d) \cdot d) \]
in BoolAlg(Mon(X)).

In order to move all the uses of Mon to the right of the uses of BoolAlg, we need a distributive law natural transformation
\[ \delta\maps \Mon \circ \BoolAlg \Rightarrow \BoolAlg \circ \Mon. \]
Given $\delta$ and the monad units and multiplications, we can define an interpretation natural transformation
\[ \interp{-}\maps \Form\Rightarrow \BoolAlg \circ \Mon \]
in the obvious way.  Below, we write subsets of Mon($X$) using set notation:
\begin{align*}
  \interp{\top}_X &= \Mon(X)\\
  \interp{\bot}_X &= \emptyset\\
  \interp{{A}\lor{B}}_X &= \interp{A}_X \cup \interp{B}_X\\
  \interp{{A}\land{B}}_X &= \interp{A}_X \cap \interp{B}_X\\
  \interp{\neg A}_X &= \Mon(X) - \interp{A}_X\\
  \interp{{A} \cdot {B}} &= \Mon(\cdot)(\interp{A} \times \interp{B})\\
  \interp{e} &= \{e\}\\
  \interp{x \in X}_X &= \{x\}
\end{align*}

Even in this simple example, we have nontrivial formulae; for example,
\[ prime = \neg e \land \neg(\neg e \cdot \neg e) \]
is a 1-line formula for primality.  It is easy to verify that $\interp{prime}_X = X.$

\subsection{Moving to 2-categories}

Monoids are associative, but the interface produced a magma, not a monoid; the words were trees of elements, not lists.  We only got associativity by modding out by a relation on the trees.  In a computational context, when a data structure has some symmetry we do not care about, we often test two instances of the structure for equality by computing a normal form for each instance and then comparing the normal forms.  For the case of a normal form for the trees, we can eliminate 1 in a product by rewriting $(1 \cdot x)$ and $(x \cdot 1)$ to $x$, and we can shift all the parentheses to the right by rewriting $((x \cdot y) \cdot z)$ to $(x \cdot (y \cdot z)).$

The Lawvere 2-theory Th(Mon) of an unnormalized monoid is much the same as the 1-theory, except for weakening some equations to rewrites and the addition of new equations between rewrites.

\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Function symbols:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $a\maps \cdot \circ (S \times \cdot) \Rightarrow \cdot \circ (\cdot \times S)$
      \item $l\maps \cdot \circ (e \times S) \circ \left \Rightarrow S$
      \item $r\maps \cdot \circ (S \times e) \circ \right \Rightarrow S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $a \circ a = (S \times a) \circ a \circ (a \times S)$ (pentagon equation)
      \item $r \times S = (S \times l) \circ a$ (triangle equation)
    \end{itemize}
  \end{itemize}
\end{center}
From Th(Mon) we can derive a 2-monad Mon that essentially produces the free monoid on a set, but keeps track of the ``internal representation'' of the monoid---a binary tree---and accounts for the work needed to convert the internal representation to its normal form.  From this perspective, we can think of the trees as programs for a simple virtual machine and the process of normalization as the execution of the program.

When we add the 2-monad BoolAlg, we get formulae like $(1 \cdot T)$ denoting the set of trees whose leftmost child is the identity; because Mon is a 2-monad, we also get proofs like 
\[ ((r \circ l) \lor y)\maps ((e \cdot (x \cdot e)) \lor y) \to (x \lor y). \]

The formulae in these examples are propositions about the structure of terms.  Later in the paper, we will show how to add modal operators that are propositions about the behavior of terms.

\section{Related work}
[[ Curry-Howard related work? ]]
[[ Lots of stuff on Lawvere theories and generalizations.  

- Lawvere, Functorial Semantics of Algebraic Theories

The original insight.

- Hyland \& Power, ``The Category Theoretic Understanding of Universal Algebra: Lawvere Theories and Monads''

  Lawvere theories and monads have been the two main category theoretic formulations of universal algebra, Lawvere theories arising in 1963 and the connection with monads being established a few years later. Monads, although mathematically the less direct and less malleable formulation, rapidly gained precedence. A generation later, the definition of monad began to appear extensively in theoretical computer science in order to model computational effects, without reference to universal algebra. But since then, the relevance of universal algebra to computational effects has been recognised, leading to renewed prominence of the notion of Lawvere theory, now in a computational setting. This development has formed a major part of Gordon Plotkin’s mature work, and we study its history here, in particular asking why Lawvere theories were eclipsed by monads in the 1960’s, and how the renewed interest in them in a computer science setting might develop in future.

- Lack \& Rosick\'y, ``Notions of Lawvere theory''

  Categorical universal algebra can be developed either using Lawvere theories (single-sorted finite product theories) or using monads, and the category of Lawvere theories is equivalent to the category of finitary monads on Set. We show how this equivalence, and the basic results of universal algebra, can be generalized in three ways: replacing Set by another category, working in an enriched setting, and by working with another class of limits than finite products.
  
- Trimble, ``multisorted Lawvere theories''

  Theorem 1. Let C be a category which admits general colimits and finite products that distribute over colimits. Then the forgetful functor ModC(Theta) to C\^Lambda is monadic.

- Lack \& Power, ``Lawvere 2-theories''

  http://www.mat.uc.pt/~categ/ct2007/slides/lack.pdf

- Power, ``Enriched Lawvere theories''

  We define the notion of enriched Lawvere theory, for enrichment over a monoidal biclosed category $V$ that is locally finitely presentable as a closed category. We prove that the category of enriched Lawvere theories is equivalent to the category of finitary monads on $V$. Moreover, the $V$-category of models of a Lawvere $V$-theory is equivalent to the $V$-category of algebras for the corresponding $V$-monad. This all extends routinely to local presentability with respect to any regular cardinal. We finally consider the special case where $V$ is $Cat$, and explain how the correspondence extends to pseudo maps of algebras.

- more
]]

\section{Categorical constructions}

\subsection{One-sorted Lawvere theories and finitary monads}

Many algebraic gadgets can be presented as a set equipped with extra structure; for example, a group is a set of elements equipped with an associative multiplication, an inversion function, and an identity element.

Let FinSet be a skeleton of the category of finite sets.  The {\bf Lawvere theory} of a mathematical gadget is a category Th(Gad) with finite products equipped with an identity-on-objects functor $\theta\maps \FinSet^\op \to \mathrm{Th(Gad)}.$  The objects of category Th(Gad) are therefore products of a generating object $S,$ the {\bf sort}.  The morphisms of Th(Gad) are necessarily generated from a set of morphisms from finite powers of $S$ to $S$ by products and composition, so a Lawvere theory may be presented with a set of function symbols
\[ f_i\maps S^{n_i} \to S, \]
together with a set of equations, where $i$ ranges over some index set $I$ and $n_i \in \NN$.  The {\bf arity} of $f_i$ is $n_i.$

A product-preserving functor from Th(Gad) to Set picks out a set and equips it with structure maps satisfying the equations.  The category Prod(Th(Gad), Set) of product-preserving functors and natural transformations between them is equivalent to the category Gad of gadgets and gadget homomorphisms.  There is a forgetful functor ${U\maps \Gad \to \Set}$ that forgets the extra structure.  The functor $U$ has a left adjoint ${L\maps \Set \to \Gad}$ that picks out the free gadget on a set.  The monad $UL\maps \Set \to \Set$ picks out the underlying set $ULX$ of the free gadget $LX$ on a set $X$.  Lawvere theories are in bijection with finitary monads; the qualifier ``finitary'' means that each function symbol has a finite arity.

For example, the Lawvere theory of groups Th(Grp) has a presentation
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Function symbols:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
      \item $inv \maps S \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $\cdot \circ (\cdot \times S) = \cdot \circ (S \times \cdot)$ (associativity)
      \item $\cdot \circ (e \times S) \circ \mathrm{left}^{-1}_S = S$ (left unit law)
      \item $\cdot \circ (S \times e) \circ \mathrm{right}^{-1}_S = S$ (right unit law)
      \item $inv \circ inv = S$ (inverse is an involution)
      \item $\cdot \circ (S \times inv) \circ \Delta = e$ (right inverse)
      \item $\cdot \circ (inv \times S) \circ \Delta = e$ (left inverse)
    \end{itemize}
    where ${\Delta\maps S \to S^2}$ is the diagonal map.
  \end{itemize}
\end{center}

A product-preserving functor from Th(Grp) to Set maps $S$ to a set $G$ and equips it with the structure of a group: it maps $\cdot$ to a binary multiplication function $G$, $e$ to a nullary function that picks out the identity element, and $inv$ to a unary function on $G$ such that $\cdot, e,$ and $inv$ satisfy the given equations.

The category Prod(Th(Grp), Set) of product-preserving functors and natural transformations between them is equivalent to the category Grp of groups and group homomorphisms.  For a functor $F$ to ``preserve products'' means that $F$ is equipped with a natural isomorphism from $F(T^n)$ to $F(T)^n.$  There is a forgetful functor from Grp to Set that forgets the structure; this forgetful functor has a left adjoint from Set to Grp that picks out the free group on a set.  The composition of these two functors gives a monad on Set that maps a set $X$ to the underlying set of the free group on $X.$

\subsection{Multisorted Lawvere theories}
In the motivation section, each grammar had only one sort; practical grammars for virtual machines are usually multisorted.  Given a finite set of sorts $\Sigma,$ the category $\FinSet/\Sigma$ is the category whose objects are pairs $(S, s\maps S\to \Sigma),$ where $S$ is a finite set, and whose morphisms are morphisms $f\maps S \to S'$ such that the relevant triangle commutes.

A {\bf multisorted Lawvere theory} is a category Th(Gad) equipped with an identity-on-objects functor ${\theta\maps (\FinSet/\Sigma)^\op \to \mathrm{Th(Gad)}.}$  The category Prod(\allowbreak Th(Gad), Set) is equivalent to the category Gad of gadgets and gadget homomorphisms.  There is a forgetful functor ${U\maps \Gad \to \Set^\Sigma}$ with a left adjoint ${L\maps \Set^\Sigma \to \Gad}$ that picks out the free gadget on a $|\Sigma|$-tuple of sets.  The monad ${UL\maps \Set^\Sigma \to \Set^\Sigma}$ picks out the underlying $|\Sigma|$-tuple of sets $ULX$ of the free gadget $LX$ on a $|\Sigma|$-tuple of sets $X$.

An example of a multisorted Lawvere theory is that of a group action on a set, which involves a choice of both a group $G$ and a set $V$ to act on.  The presentation of Th(GrpAct) has a pair of sorts $S = (G, V)$, all the function symbols and equations as the theory of a group (replacing $S$ by $G$), together with a new function symbol
\begin{itemize}
  \item $a\maps G \times V \to V$
\end{itemize}
and equations
\begin{itemize}
  \item $a \circ (e \times V) \circ \mathrm{left}_V = V$ (identity action)
  \item $a \circ (m \times V) = a \circ (G \times a)$ (compatibility).
\end{itemize}

\subsection {Multisorted Lawvere 2-theories}
In this paper, the {\bf multisorted Lawvere 2-theory} of a gadget is a 2-category Th(Gad) with strict finite products equipped with an identity-on-objects functor $\theta\maps (\FinSet/\Sigma)^\op \to \mathrm{Th(Gad)},$ where we promote $(\FinSet/\Sigma)$ to a 2-category by adding identity 2-morphisms to every 1-morphism.  As noted in the related work section, other authors have considered much more powerful notions of 2-theory, but we will not need the extra features.  A multisorted Lawvere 2-theory may be presented by a finite set of sorts, a set of function symbols with finite arity, a set of rewrites, and a set of equations between rewrites.  

Multisorted Lawvere 2-theories have models in $\Cat^\Sigma.$  As with 1-theories, the 2-category of product-preserving functors from Th(Gad) to $\Cat^\Sigma$, natural transformations, and modifications is equivalent to the 2-category of gadgets, gadget homomorphisms, and gadget transformations.  [[ Get the details right on just what kind of strictness for gadgets, homs, and nts. ]] For a functor $F$ to preserve products means that it is equipped with a natural equivalence between $F(T^n)$ and $F(T)^n.$

The ``free pointed magma on a set equipped with normalization'' from the introduction is an example of a single-sorted Lawvere 2-theory; another example of a single-sorted Lawvere 2-theory is the theory of the SKI combinator calculus, a Turing-complete programming language that was a predecessor to the lambda calculus.  Th(SKI) has a presentation
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $T$
    \end{itemize}
    \item Function symbols:
    \begin{itemize}
      \item $S\maps 1 \to T$
      \item $K\maps 1 \to T$
      \item $I\maps 1 \to T$
      \item $(-\;-)\maps T^2 \to T,$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $\forall x,y,z \in T, \quad \sigma \maps (((S\; x)\; y)\; z) \Rightarrow ((x\; z)\; (y\; z))$
      \item $\forall y,z \in T, \quad \kappa \maps ((K\; y)\; z) \Rightarrow y$
      \item $\forall z \in T, \quad \iota \maps (I\; z) \Rightarrow z$
    \end{itemize}
    \item No equations.
  \end{itemize}
\end{center}
The Church-Rosser theorem for the SKI calculus in this context says that any two terminating rewrites out of an SKI term have the same codomain; however, we do not want to impose equality on the rewrites, since they can differ greatly in computational complexity.  For example, suppose that we have the term $((K\; I)\; x),$ where $x$ is some term that takes a long time to reduce to its normal form; a rewrite that reduces $x$ first and then uses $\kappa$ takes much longer than just doing $\kappa$ first, though both rewrites begin and end at the same term.

The free model of Th(SKI) on a category takes its objects as terms and its morphisms as rewrites, then freely adjoins $S,K,$ and $I$ and all applications of one object to another, as well as new morphisms generated by $\sigma,\kappa,$ and $\iota.$  The free model on the empty category will contain only terms and rewrites from the SKI calculus.

Lawvere 2-theories encode nondeterminism by means of multiple possible rewrites between function symbols.  Here's a presentation of a toy theory Th(Lock) for acquiring a mutex.
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $T$ for terms
      \item $N$ for names
    \end{itemize}
    \item Function symbols:
    \begin{itemize}
      \item $lock\maps 1 \to T$
      \item $request\maps N \to T$
      \item $acquired\maps N \to T$
      \item $|\maps T^2 \to T$
      \item $0 \maps 1 \to T$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $\forall x \in T, \quad u\maps 0|x \Rightarrow x$
      \item $\forall x,y \in T,\quad c\maps x|y \stackrel{\sim}{\Rightarrow} y|x$
      \item $\forall x,y,z \in T,\quad a\maps (x|y)|z \stackrel{\sim}{\Rightarrow} x|(y|z)$
      \item $\forall n \in N,\quad get\maps lock | request(n) \stackrel{\sim}{\Rightarrow} acquired(n)$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $u = T$ (| is unital)
      \item $c = T^2$ (| is commutative)
      \item $a = T^3$ (| is associative)
    \end{itemize}
  \end{itemize}
\end{center}
In the free model of this theory on $(T, N) = (\emptyset, \{ a,b\})$, there are two different non-identity rewrites out of
\[ lock \;|\; request(a) \;|\; request(b). \]
One rewrite is to
\[ acquired(a) \;|\; request(b), \]
and the other to
\[ request(a) \;|\; acquired(b). \]

\section{Categories of formulae and proofs}

Any 1-theory of collections can be promoted to a 2-theory by turning each equation into a rewrite, then adding an equation asserting that the rewrite is equal to the identity rewrite.  Therefore as before, given a single-sorted Lawvere 2-theory Th(Gad), we get a 2-theory of formulae Th(Form) by adding a 2-theory of collections Th(Coll).  The models of Th(Form) are categories of formulae and proofs.

For multisorted Lawvere 2-theories, there is no canonical choice of sorts to identify between the theory of the machine and the theory of the collection, but in practical applications, there is often an obvious choice; for example, given the theory of a lock from the previous section, we probably want our formulae to talk about $T$ more than about $N$.  With that choice, the formula for those terms where the lock is available is $lock\;|\;\top,$ and $\neg(lock \;|\;\top)$ is the formula for those terms where the lock has been acquired.

\section{Interpretation}

[[ Thm: defining and as intersect, or as union, top as the whole set, bot as the empty set, neg as complement, and terms over collections as mapping the term constructor over the cartesian product of the collections always works. ]]

[[ Thm: sound & complete ]]

\section{Modal operators}

So far, all the examples of formulae have dealt with the structure of the term.  Far more interesting are sets of terms that all share some behavior.  For example, in the SKI calculus, we want to add the idea of an arrow type to our formulae, and have the interpretation of $A \lhom B$ be the set of terms $t$ such that given a term $u\in\interp{A}$, the term eventually evolves to a term $v\in\interp{B}.$

This notion of eventuality is an example of a modal operator.  Possibility is another, and possibility is to eventuality as ``there exists'' is to ``for all''.  Many interesting properties can be stated in terms of eventual and possible states, like
\begin{itemize}
  \item Security: it is not the case that my banking service will evolve to a state in which someone other than the bank and me has the ability to withdraw money from my account.
  \item Liveness: this process will always eventually handle another message.
  \item Termination: this computation will always halt.
  \item Structure: at the end of sorting, the data will be ordered.
\end{itemize}

To add a modal operator to a formula language, first add it formally a function symbol to the term theory, then add the collection theory as before.  

To interpret the modal operator, first interpret the formulae as above, then interpret modal terms as collections of terms, then use the join from the collection monad.

\subsection{Example: Arrow types in the SKI calculus}

The Lawvere 2-theory of the arrow type Th(Arrow) has one function symbol, no rewrites, and no equations.  The lack of rewrites and equations are because the arrow is a purely formal type, and it is only in our choice of semantics that it acquires its customary interpretation.
\begin{itemize}
  \item Sorts:
  \begin{itemize}
    \item $T$
  \end{itemize}
  \item Function symbols:
    \begin{itemize}
      \item $\lhom\maps T \to T$
    \end{itemize}
  \item No rewrites.
  \item No equations.
\end{itemize}

We get the theory of SKI with arrow Th(SKIArr) by adding Th(SKI) to Th(Arrow), and we get the theory of formulae Th(Form) by adding Th(SKIArr) to Th(BoolAlg).

To interpret terms from Th(Form), we compose the interpretation natural transformation above with another natural transformation $\alpha\maps SKIArr \to BoolAlg \circ SKI,$ followed by the join from the collection monad.  In particular, 
\begin{align*}
  \alpha(u \lhom v) &= \{ t | \exists \rho\maps (t\; u) \Rightarrow v \}\\
  \alpha(t \in \mathrm{Th(SKI)}) &= \{ t \}.\\
\end{align*}

\begin{align*}
  \interp{}
\end{align*}
\end{document}