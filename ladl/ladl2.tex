\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{stmaryrd}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\maps}{\colon}
\newcommand{\FinSet}{\mathrm{FinSet}}
\newcommand{\Set}{\mathrm{Set}}
\newcommand{\Cat}{\mathrm{Cat}}
\newcommand{\Mach}{\mathrm{Mach}}
\newcommand{\Mon}{\mathrm{Mon}}
\newcommand{\BoolAlg}{\mathrm{BoolAlg}}
\newcommand{\Form}{\mathrm{Form}}
\newcommand{\leftu}{\mathrm{left}}
\newcommand{\rightu}{\mathrm{right}}
\newcommand{\send}{\mathrm{send}}
\newcommand{\recv}{\mathrm{recv}}
\newcommand{\comm}{\mathrm{comm}}
\renewcommand{\quote}[1]{``#1"}
\newcommand{\deref}[1]{\mathrm{eval}(#1)}
\newcommand{\op}{\mathrm{op}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\lhom}{\Rightarrow}

\title{Logic as a distributive law}
\author{
Michael Stay\\
  {Pyrofex Corp.}\\
  {\fontsize{8}{8}\selectfont stay@pyrofex.net}
\and
L.G. Meredith\\
  {Biosimilarity, LLC}\\
  {\fontsize{8}{8}\selectfont lgreg.meredith@biosimilarity.com}
}
\begin{document}
\maketitle
\begin{abstract}
\noindent
  We present an algorithm for deriving a spatial-behavioral type system from a formal presentation of a virtual machine.  Given a 2-monad $\Mach\maps \Cat \to \Cat$ for the free machine on a category of states and rewrites and a 2-monad BoolAlg for the free Boolean algebra on a category, we get a 2-monad Form = BoolAlg + Mach for the free category of formulae and proofs.  We also get the 2-monad $\BoolAlg \circ \Mach$ for subsets of machine states. 

  The interpretation of formulae is a natural transformation $\interp{-} \maps \Form \Rightarrow \BoolAlg \circ \Mach$ defined by the units and multiplications of the monads and a distributive law transformation $\delta\maps \Mach \circ \BoolAlg \Rightarrow \BoolAlg \circ \Mach.$

  We exhibit nontrivial formulae encoding confinement and liveness properties for a reflective higher-order variant of the pi calculus.

\end{abstract}
\section{Introduction}

  Sylvester coined the term ``universal algebra'' to describe the idea of expressing a mathematical structure as set equipped with functions satisfying equations; the idea itself was first developed by Hamilton and de Morgan \cite{Whitehead}.  Most modern programming languages have a notion of a ``module'' or an ``interface'' with this same information; for example, consider this Agda definition of a monoid.
  \begin{verbatim}
    data Monoid (M : Set)(Eq : Equivalence M) : Set where
      monoid :
        (e   : M)
        (_*_ : M -> M -> M)
        (leftId : LeftIdentity Eq z _+_)
        (rightId : RightIdentity Eq z _+_)
        (assoc : Associative Eq _+_) ->
  \end{verbatim}
  The code defines a sort $M$, a nullary term constructor $e$, and a binary term constructor $*,$ subject to three equations.  In universal algebra, such a structure is called an ``equational theory''.

  In 1963, Lawvere \cite{Lawvere} showed that an equational theory was a presentation of a category with finite products where all the objects are powers of a single generating object, now called a Lawvere theory.  The Agda code above is a presentation of a category Th(Mon) whose objects are $1, M, M^2, M^3, \ldots,$ and whose morphisms are generated by projections, $e,$ and $*,$ modulo the equations.  This category is purely syntactic, in the sense that everything is just symbols, just formal expressions.

  To interpret the equational theory as denoting sets and functions, we take a product-preserving functor from the Lawvere theory to Set.  The category Set encodes what we mean by semantics; if instead of Set we used the category Vect of vector spaces and linear maps and mapped the product in Th(Mon) to the tensor product in Vect, a model of the theory would be an associative algebra instead.  If we used a category of endofunctors and natural transformations and mapped the product in Th(Mon) to composition, a model of the theory would be a monad.

  The category of product-preserving functors from Th(Mon) to Set and natural transformations between them is equivalent to the category Mon of monoids and monoid homomorphisms.  There is a forgetful functor $U\maps \Mon \to \Set$ that forgets all the structure with a left adjoint $L\maps \Set to \Mon$ that picks out the free monoid on a set.  Abusing notation somewhat, we use Mon also to mean the monad $UL$ that picks out the underlying set of the free monoid on a set.  This pattern is a general one: every Lawvere theory corresponds to a finitary monad on Set and vice-versa \cite{HylandPower}.

  Lawvere theories can be generalized from 1-categories to 2-categories.  As one might expect, the corresponding notion of equational theory involves one more level of structure; we have sorts, term constructors, {\em rewrites} instead of equations between term constructors, and equations between rewrites.  We typically interpret such a theory in Cat, the 2-category of categories and functors between them.

  We can use Lawvere 2-theories to describe the state of a virtual machine and the permissible rewrites.  We have a sort for machine states, term constructors for building up specific states, rewrites between term constructors for running the machine, and equations between rewrites to preserve invariants.  The Lawvere 2-theory captures the syntax of a virtual machine; a 2-functor from the theory into Cat assigns operational semantics.

  A spatial-behavioral type system is a language in which one can describe both the structure and future behavior of virtual machine states.  The interpretation of a formula should be a set of terms satisfying the formula.  The interpretation of a proof should be a function that maps a set of assumptions to a set of consequents.

  The obvious language for describing the structure of a machine state is the 2-theory Th(Mach) of the machine itself, equipped with extra term constructors for true, false, disjunction, conjunction, and negation.  This suggests adding the 2-monad Mach to the 2-monad BoolAlg for Boolean algebras to get Form, the 2-monad for formulae.

  The obvious language for interpreting formulae is the 2-category of subsets of machine states with pointwise rewrites between them.  This suggests composing the monad BoolAlg with the monad Mach.

  The obvious way to interpret formulae is then a natural transformation $\interp{-} \maps \Form \Rightarrow \BoolAlg \circ \Mach$ defined by the units and multiplications of the monads and a distributive law transformation $\delta\maps \Mach \circ \BoolAlg \Rightarrow \BoolAlg \circ \Mach.$  Soundness and completeness follow easily.

  We can extend this naive type system with fixed points and with modal operators that denote sets of terms that all exhibit a particular behavior; for example of the latter, the arrow type $A \Rrightarrow B$ in lambda calculus is the type of terms that when applied to a term of type $A$ eventually rewrite to a term of type $B$.  Other formulae can capture eventual properties like
\begin{itemize}
  \item Authority: it is the case that if my banking service eventually evolves to a state in which Alice has the ability to withdraw money from my account, then the banking service both sent an email to my address requesting confirmation and received the confirmation email in response.
  \item Confinement: this process will only ever send a messages on channels in this set.
  \item Liveness: this process will always eventually handle another message.
  \item Termination: this computation will always halt.
  \item Structure: at the end of sorting, the data will be ordered.
\end{itemize}

\section{Related work}
[[ Curry-Howard related work? ]]
[[ Lots of stuff on Lawvere theories and generalizations.  

- Lawvere, Functorial Semantics of Algebraic Theories

The original insight.

- Hyland \& Power, ``The Category Theoretic Understanding of Universal Algebra: Lawvere Theories and Monads''

  Lawvere theories and monads have been the two main category theoretic formulations of universal algebra, Lawvere theories arising in 1963 and the connection with monads being established a few years later. Monads, although mathematically the less direct and less malleable formulation, rapidly gained precedence. A generation later, the definition of monad began to appear extensively in theoretical computer science in order to model computational effects, without reference to universal algebra. But since then, the relevance of universal algebra to computational effects has been recognised, leading to renewed prominence of the notion of Lawvere theory, now in a computational setting. This development has formed a major part of Gordon Plotkin’s mature work, and we study its history here, in particular asking why Lawvere theories were eclipsed by monads in the 1960’s, and how the renewed interest in them in a computer science setting might develop in future.

- Lack \& Rosick\'y, ``Notions of Lawvere theory''

  Categorical universal algebra can be developed either using Lawvere theories (single-sorted finite product theories) or using monads, and the category of Lawvere theories is equivalent to the category of finitary monads on Set. We show how this equivalence, and the basic results of universal algebra, can be generalized in three ways: replacing Set by another category, working in an enriched setting, and by working with another class of limits than finite products.
  
- Trimble, ``multisorted Lawvere theories''

  Theorem 1. Let C be a category which admits general colimits and finite products that distribute over colimits. Then the forgetful functor ModC(Theta) to C\^Lambda is monadic.

- Lack \& Power, ``Lawvere 2-theories''

  http://www.mat.uc.pt/~categ/ct2007/slides/lack.pdf

- Power, ``Enriched Lawvere theories''

  We define the notion of enriched Lawvere theory, for enrichment over a monoidal biclosed category $V$ that is locally finitely presentable as a closed category. We prove that the category of enriched Lawvere theories is equivalent to the category of finitary monads on $V$. Moreover, the $V$-category of models of a Lawvere $V$-theory is equivalent to the $V$-category of algebras for the corresponding $V$-monad. This all extends routinely to local presentability with respect to any regular cardinal. We finally consider the special case where $V$ is $Cat$, and explain how the correspondence extends to pseudo maps of algebras.

- more
]]

\section{A 1-categorical example}

Here we return in slightly greater detail to the example of the logic for the language of monoids.  Because we are working with categories instead of 2-categories, the ``virtual machine'' is particularly bland; it only has states (the elements of the monoid), not rewrites.

Let FinSet be a skeleton of the category of finite sets.  The Lawvere theory of a machine is a category Th(Mach) with finite products equipped with an identity-on-objects functor $\theta\maps \FinSet^\op \to \mathrm{Th(Mach)}.$  Because the objects of FinSet are coproducts of the one-element set, the objects of category Th(Mach) are therefore products of a generating object we will write as $S,$ for ``sort''.  The morphisms of Th(Mach) are generated from a set of morphisms from finite powers of $S$ to $S$ by products and composition, so Th(Mach) may be presented by 
\begin{itemize}
  \item a sort $S$,
  \item a set of term constructors $f_i\maps S^{n_i} \to S,$ where $i$ ranges over some index set $I$ and $n_i \in \NN,$
  \item and a set of equations between term constructors.
\end{itemize}
We say the arity of $f_i$ is $n_i.$

A product-preserving functor from Th(Mach) to Set picks out a set and equips it with structure maps satisfying the equations.  The category Prod(Th(Mach), Set) of product-preserving functors and natural transformations between them is equivalent to the category Mach of machines and machine homomorphisms.  There is a forgetful functor ${U\maps \Mach \to \Set}$ that forgets the extra structure.  The functor $U$ has a left adjoint ${L\maps \Set \to \Mach}$ that picks out the free machine on a set of base states.  The monad $\Mach = UL\maps \Set \to \Set$ picks out the underlying set $ULX$ of the free machine $LX$ on a set $X$.  Lawvere theories are in bijection with finitary monads; the qualifier ``finitary'' means that each term constructor has a finite arity.

Here is a presentation of the ``Lawvere theory of a monoid'' Th(Mon):\\
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $\cdot \circ (S \times \cdot) = \cdot \circ (\cdot \times S)$ (associativity)
      \item $\cdot \circ (e \times S) \circ \leftu^{-1} = S$ (left unit)
      \item $\cdot \circ (S \times e) \circ \rightu^{-1} = S$ (right unit)        
    \end{itemize}
  \end{itemize}
\end{center}
where ${\leftu\maps 1 \times S \stackrel{\sim}{\to} S}$ and ${\rightu\maps S \times 1 \stackrel{\sim}{\to} S}$ are the canonical isomorphisms.

An implementation of this specification is a product-preserving functor from Th(Mon) to Set; such a functor will assign a set of values to the sort and functions to the term constructors such that the equations are satisfied, {\em i.e.} it will pick out a monoid.  The category of product-preserving functors from Th(Mon) to Set and natural transformations between them is equivalent to the category of monoids and monoid homomorphisms.  There is a forgetful functor $U\maps \Mon \to \Set$ that forgets the multiplication and unit, and outputs the underlying set of elements.  The functor $U$ has a left adjoint $L\maps \Set \to \Mon$ that outputs the free monoid on a set.  The composite functor $\Mon = UL\maps \Set \to \Set$ is the corresponding monad.

All our formulae about monoids will denote subsets of the elements of the monoid; we use Th(BoolAlg) to describe them.  We take as our universe of subsets those describable with a finite formula, so that the logic is complete by construction.
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $\land\maps S^2 \to S$
      \item $\lor\maps S^2 \to S$
      \item $\top\maps 1 \to S$
      \item $\bot\maps 1 \to S$
      \item $\neg\maps S \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item associativity, commutativity and unit laws for $\land$ and $\lor$
      \item distributivity of $\land$ over $\lor$
      \item involution for $\neg$
      \item de Morgan's laws
    \end{itemize}
  \end{itemize}
\end{center}
From this theory, we can derive the monad BoolAlg for the free Boolean algebra on a set.

The sum of the two theories above is a new theory Th(Form) = Th(Mon) + Th(BoolAlg) whose terms are our formulae.  Th(Form) is presented by identifying the sorts and taking the union of the term constructors and the union of the equations.
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
      \item $\land\maps S^2 \to S$
      \item $\lor\maps S^2 \to S$
      \item $\top\maps 1 \to S$
      \item $\bot\maps 1 \to S$
      \item $\neg\maps S \to S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item associativity and unit laws for $\cdot$
      \item associativity, commutativity, and unit laws for $\land$ and $\lor$
      \item involution for $\neg$
      \item de Morgan's laws
    \end{itemize}
  \end{itemize}
\end{center}
The process of deriving a monad from a theory preserves sums.  Since the sum of two monads is the free product of the two, a general formula will be a term in an alternating composition of the two monads.  For example, suppose that $a, b, c, d \in X;$ then one formula is
\[ (({a}\lor{(b \cdot d)}) \cdot ({c}\lor{d})), \]
which is a term in Mon(BoolAlg(Mon($X$))).  The interpretation of this formula should be the set of monoid elements
\[ \{ ac, ad, bdc, bdd \}, \]
or in other words, the term
\[ (a \cdot c) \lor (a \cdot d) \lor ((b \cdot d) \cdot c) \lor ((b \cdot d) \cdot d) \]
in BoolAlg(Mon(X)).

In order to move all the uses of Mon to the right of the uses of BoolAlg in the alternating composition, we need a distributive law natural transformation
\[ \delta\maps \Mon \circ \BoolAlg \Rightarrow \BoolAlg \circ \Mon. \]
Given $\delta$ and the monad units and multiplications, we can define an interpretation natural transformation
\[ \interp{-}\maps \Form\Rightarrow \BoolAlg \circ \Mon \]
in the obvious way.  Below, we write subsets of Mon($X$) using set notation:
\begin{align*}
  \interp{\top}_X &= \Mon(X)\\
  \interp{\bot}_X &= \emptyset\\
  \interp{{A}\lor{B}}_X &= \interp{A}_X \cup \interp{B}_X\\
  \interp{{A}\land{B}}_X &= \interp{A}_X \cap \interp{B}_X\\
  \interp{\neg A}_X &= \Mon(X) - \interp{A}_X\\
  \interp{{A} \cdot {B}} &= \Mon(\cdot)(\interp{A} \times \interp{B})\\
  \interp{e} &= \{e\}\\
  \interp{x \in X}_X &= \{x\}
\end{align*}

Even in this simple example, we have nontrivial formulae; for example,
\[ prime = \neg e \land \neg(\neg e \cdot \neg e) \]
is a 1-line formula for primality.  For the monoid of natural numbers under multiplication, this formula says a number is prime if it neither is 1 nor has a nontrivial factorization.  It is easy to verify that $\interp{prime}_X = X.$

\section{Moving to 2-categories}

In a computational context, when a data structure has some symmetry we do not care about, we often test two instances of the structure for equality by computing a normal form for each instance and then comparing the normal forms.  Monoids are associative, but we can imagine storing words of a monoid as binary trees internally and then comparing them by computing a normal form.  For the case of a normal form for the trees, we can eliminate 1 in a product by rewriting $(1 \cdot x)$ and $(x \cdot 1)$ to $x$, and we can shift all the parentheses to the right by rewriting $((x \cdot y) \cdot z)$ to $(x \cdot (y \cdot z)).$

The Lawvere 2-theory Th(Mon) is much the same as the 1-theory, except for the weakening of some equations to rewrites and the addition of new equations between the rewrites.

\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $S$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $\cdot\maps S^2 \to S$
      \item $e\maps 1 \to S$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $a\maps \cdot \circ (S \times \cdot) \Rightarrow \cdot \circ (\cdot \times S)$
      \item $l\maps \cdot \circ (e \times S) \circ \leftu \Rightarrow S$
      \item $r\maps \cdot \circ (S \times e) \circ \rightu \Rightarrow S$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $a \circ a = (S \times a) \circ a \circ (a \times S)$ (pentagon equation)
      \item $r \times S = (S \times l) \circ a$ (triangle equation)
    \end{itemize}
  \end{itemize}
\end{center}
From Th(Mon) we can derive a 2-monad Mon that essentially produces the free monoid on a set, but keeps track of the internal representation of the monoid---a binary tree---and accounts for the work needed to convert the internal representation to its normal form.  From this perspective, we can think of the trees as programs for a simple virtual machine and the process of normalization as the execution of the program.  Later in the paper, we will examine the case of the SKI combinator calculus, a Turing-complete programming language that was a predecessor to the lambda calculus; it, too, uses binary trees as programs, and execution of the program is a normalization process.

When we add the 2-monad BoolAlg to Mon, we get formulae like $(1 \cdot \top)$ denoting the set of trees whose leftmost child is the identity; because Mon is a 2-monad, we also get proofs like 
\[ ((r \circ l) \lor y)\maps ((e \cdot (x \cdot e)) \lor y) \to (x \lor y) \]
whose interpretations are homomorphisms of Boolean algebras.

The formulae in these examples have been propositions about the structure of terms.  Later in the paper, we will also show how to add modal operators that are propositions about the behavior of terms.

\section{Multisorted Lawvere theories}
In the motivation section, each theory had only one sort; practical theories for virtual machines are usually multisorted.  Given a finite set of sorts $\Sigma,$ the category $\FinSet/\Sigma$ is the category whose objects are pairs $(S, s\maps S\to \Sigma),$ where $S$ is a finite set, and whose morphisms are morphisms $f\maps S \to S'$ such that the relevant triangle commutes.

A multisorted Lawvere theory is a category Th(Mach) with finite products equipped with an identity-on-objects functor ${\theta\maps (\FinSet/\Sigma)^\op \to \mathrm{Th(Mach)}.}$  The category Prod(Th(Mach), Set) is equivalent to the category Mach of machines and machine homomorphisms.  There is a forgetful functor ${U\maps \Mach \to \Set^\Sigma}$ with a left adjoint ${L\maps \Set^\Sigma \to \Mach}$ that picks out the free machine on a $|\Sigma|$-tuple of sets.  The monad ${UL\maps \Set^\Sigma \to \Set^\Sigma}$ picks out the underlying $|\Sigma|$-tuple of sets $ULX$ of the free machine $LX$ on a $|\Sigma|$-tuple of sets $X$.

An example of a multisorted Lawvere theory is that of a group action on a set, which involves a choice of both a group $G$ and a set $V$ to act on.  The presentation of Th(GrpAct) has a pair of sorts $(G, V)$, all the term constructors and equations as the theory of a group (where we replace $S$ by $G$), together with a new term constructor
\begin{itemize}
  \item $a\maps G \times V \to V$
\end{itemize}
and equations
\begin{itemize}
  \item $a \circ (e \times V) \circ \mathrm{left}_V = V$ (identity action)
  \item $a \circ (m \times V) = a \circ (G \times a)$ (compatibility).
\end{itemize}

Another example is the theory of a directed graph.
\begin{itemize}
  \item Sorts:
  \begin{itemize}
    \item $E$ for edges
    \item $V$ for vertices
  \end{itemize}
  \item Term constructors:
  \begin{itemize}
    \item $s\maps E \to V$ for the source of an edge
    \item $t\maps E \to V$ for the target of an edge
  \end{itemize}
  \item No equations.
\end{itemize}

\section {Lawvere 2-theories}
In this paper, the multisorted Lawvere 2-theory of a machine is a 2-category Th(Mach) with strict finite products (that is, its underlying category has products) equipped with an identity-on-objects functor $\theta\maps (\FinSet/\Sigma)^\op \to \mathrm{Th(Mach)},$ where we promote $(\FinSet/\Sigma)$ to a 2-category by adding identity 2-morphisms to every 1-morphism.  As noted in the related work section, other authors have considered much more powerful notions of 2-theory, but we will not need the extra features.  Our notion of a multisorted Lawvere 2-theory may be presented by a finite set of sorts, a set of term constructors with finite arity, a set of rewrites, and a set of equations between rewrites.  

Our models of multisorted Lawvere 2-theories are functors into $\Cat^\Sigma$ that preserve products up to isomorphism, not merely up to equivalence; that is, the 2-functor has an underlying functor that preserves products.  As with 1-theories, the 2-category of product-preserving functors from Th(Mach) to $\Cat^\Sigma$, natural transformations, and modifications is equivalent to the 2-category of machines, machine homomorphisms, and machine transformations.

As mentioned above, the SKI combinator calculus is a Turing-complete language; it was invented by Moses Schoenfinkel and Haskell Curry in the 1920s as a way to clarify the role of quantified variables in logic, essentially by eliminating them.  The single-sorted Lawvere 2-theory Th(SKI) has a presentation
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $T$
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $S\maps 1 \to T$
      \item $K\maps 1 \to T$
      \item $I\maps 1 \to T$
      \item $(-\;-)\maps T^2 \to T,$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $\forall x,y,z \in T, \quad \sigma \maps (((S\; x)\; y)\; z) \Rightarrow ((x\; z)\; (y\; z))$
      \item $\forall y,z \in T, \quad \kappa \maps ((K\; y)\; z) \Rightarrow y$
      \item $\forall z \in T, \quad \iota \maps (I\; z) \Rightarrow z$
    \end{itemize}
    \item No equations.
  \end{itemize}
\end{center}
In this context, the Church-Rosser theorem for the SKI calculus says that any two terminating rewrites out of an SKI term have the same codomain.  We do not usually want to impose equality on the rewrites, since they can differ greatly in computational complexity.  For example, suppose that we have the term $((K\; I)\; x),$ where $x$ is some term that takes a long time to reduce to its normal form; a rewrite that reduces $x$ first and then uses $\kappa$ takes much longer than just doing $\kappa$ first, though both rewrites begin and end at the same term.

The free model of Th(SKI) on a category takes its objects as terms and its morphisms as rewrites, then freely adjoins $S,K,$ and $I$ and all applications of one object to another, as well as new morphisms generated by $\sigma,\kappa,$ and $\iota.$  The free model on the empty category will contain only terms and rewrites from the SKI calculus.

Lawvere 2-theories encode nondeterminism by means of multiple possible rewrites between term constructors.  Here's a presentation of a toy theory Th(Lock) for acquiring mutexes.
\begin{center}
  \begin{itemize}
    \item Sorts:
    \begin{itemize}
      \item $T$ for terms
      \item $N$ for names
    \end{itemize}
    \item Term constructors:
    \begin{itemize}
      \item $lock\maps 1 \to T$
      \item $request\maps N \to T$
      \item $acquired\maps N \to T$
      \item $|\maps T^2 \to T$
      \item $0 \maps 1 \to T$
    \end{itemize}
    \item Rewrites:
    \begin{itemize}
      \item $\forall x \in T, \quad u\maps 0|x \Rightarrow x$
      \item $\forall x,y \in T,\quad c\maps x|y \stackrel{\sim}{\Rightarrow} y|x$
      \item $\forall x,y,z \in T,\quad a\maps (x|y)|z \stackrel{\sim}{\Rightarrow} x|(y|z)$
      \item $\forall n \in N,\quad get\maps lock | request(n) \stackrel{\sim}{\Rightarrow} acquired(n)$
    \end{itemize}
    \item Equations:
    \begin{itemize}
      \item $u = T$ (| is unital)
      \item $c = T^2$ (| is commutative)
      \item $a = T^3$ (| is associative)
    \end{itemize}
  \end{itemize}
\end{center}
In the free model of this theory on $(T, N) = (\emptyset, \{ a,b\})$, there are two different non-identity rewrites out of
\[ lock \;|\; request(a) \;|\; request(b). \]
One rewrite is to
\[ acquired(a) \;|\; request(b), \]
and the other to
\[ request(a) \;|\; acquired(b). \]

\section{Categories of formulae and proofs}

Any 1-theory can be promoted to a 2-theory by turning each equation into a rewrite, then adding an equation asserting that the rewrite is equal to the identity rewrite.  Therefore as before, given a single-sorted Lawvere 2-theory Th(Mach), we get a 2-theory of formulae Th(Form) by adding the 2-theory of Boolean algebras Th(BoolAlg).  The models of Th(Form) are categories of formulae and proofs.

For multisorted Lawvere 2-theories, there is no canonical choice of sorts to identify between the theory of the machine and the theory of Boolean algebras, but in practical applications, there is often an obvious choice; for example, given the theory of locks from the previous section, we probably want our formulae to talk about $T$ more than about $N$.  With that choice, the formula for those terms where the lock is available is $lock\;|\;\top,$ and $\neg(lock \;|\;\top)$ is the formula for those terms where the lock has been acquired.

That said, one may also choose to add two different copies of Th(BoolAlg) and identify each single sort with different sorts in the theory of the machine; in the case of the theory of locks, adding one copy of BoolAlg for names as well as for terms lets us write formulae like
\[ request({a}\lor{b}) \;|\; \top \]
that says that at least $a$ or $b$ is requesting the lock.  Later in the paper, we will see how we can use formulae involving names to create namespaces that enforce containment on processes in the pi calculus.

\section{Interpretation}

[[ Thm: defining and as intersect, or as union, top as the whole set, bot as the empty set, neg as complement, and terms over collections as mapping the term constructor over the cartesian product of the collections is sound and complete. ]]

\section{Modal operators}

So far, all the examples of formulae have dealt with the structure of the term.  Far more interesting are sets of terms that all share some behavior.  For example, in the SKI calculus, we want to add the idea of an arrow type to our formulae, and have the interpretation of $A \lhom B$ be the subset of terms $t$ such that given a term $u\in\interp{A}$, the term $(t\; u)$ eventually evolves to a term $v\in\interp{B}.$

This notion of eventuality is an example of a modal operator.  Possibility is another, where possibility is to eventuality as ``there exists'' is to ``for all''.  Many interesting properties can be stated in terms of eventual and possible states, like
\begin{itemize}
  \item Security: it is not the case that my banking service will evolve to a state in which someone other than the bank and me has the ability to withdraw money from my account.
  \item Liveness: this process will always eventually handle another message.
  \item Termination: this computation will always halt.
  \item Structure: at the end of sorting, the data will be ordered.
\end{itemize}

To add a modal operator to a formula language, we first add it formally a term constructor to the term theory, then add the collection theory as before.  

To interpret the modal operator, we first interpret the formulae as above, then interpret modal terms as collections of terms, then use the join from the collection monad.

\subsection{Example: Arrow types in the SKI calculus}

The Lawvere 2-theory of the arrow type Th(Arrow) has one term constructor, no rewrites, and no equations.  The lack of rewrites and equations are because the arrow is a purely formal type, and it is only in our choice of semantics that it acquires its customary interpretation.
\begin{itemize}
  \item Sorts:
  \begin{itemize}
    \item $T$
  \end{itemize}
  \item Term constructors:
    \begin{itemize}
      \item $\lhom\maps T^2 \to T$
    \end{itemize}
  \item No rewrites.
  \item No equations.
\end{itemize}

We get the theory of SKI with arrow Th(SKIArr) by adding Th(SKI) to Th(Arrow), and we get the theory of formulae Th(Form) by adding Th(SKIArr) to Th(BoolAlg).

To interpret terms from Th(Form), we compose the interpretation natural transformation above with another natural transformation $\alpha\maps \mathrm{SKIArr} \Rightarrow \mathrm{BoolAlg} \circ \mathrm{SKI},$ followed by the join from the collection monad.  In particular, 
\[ \alpha(u \lhom v) = \{ t \;|\; \exists \rho\maps (t\; u) \Rightarrow v \}. \]

In Lambek's 1980 paper on the denotational semantics of the lambda calculus, he defined a category whose objects were types and whose morphisms were equivalence classes of lambda terms with one free variable.  In a future paper, we will show how Mellies and Zeilberger's approach to type refinement lets us recapitulate Lambek's construction and extend the arrow to a profunctor.

\subsection{Modal operators parametric in a term constructor}

A term context is a term with a ``hole'' that can be filled by some other term.  Given a Lawvere theory with a sort $S$ for terms, one can derive a new theory of term contexts by replacing each term constructor $f\maps S^n \to S$ with $n$ term constructors $f_i\maps S^{n-1} \to S$ where $1 \le i \le n$.  We think of $f_i$ as being $f$ with the $i$th input being a hole.  Equivalently, if we have a theory with coproducts, we can replace each occurrence of $S$ on the left-hand side of a term constructor with $S+1,$ where the new point represents the hole.

The arrow type is a special case of a general modal operator parametrized by a two-hole term context $C.$  We denote the operator itself with angle brackets as a reminder of the diamond ``possibly'' modality: $u \langle C \rangle v.$  The interpretation is similar to that of the arrow:
\[ \alpha(u \langle C\rangle v) = \{ t \;|\; \exists \rho\maps C[t, u] \Rightarrow v \}. \]

\section{Recursion}

As with modal operators, we add Suppose that we have a single-sorted Lawvere 2-theory of a virtual machine with sort $S$.  We add recursion to our formulae by introducing a new sort $V$ for type variables and new term constructors 
\begin{itemize}
  \item $- \maps V \to S$ to let us use type variables in formulae and
  \item $\mu\maps V\times S \to S$ to express fixed points.
\end{itemize}

We interpret terms of the form $\mu X.P[X]$ as [[ ... ]]

\subsection{The reflective higher-order pi calculus}

Lawvere theories are limited in that they only talk about products of sorts.  A lambda theory is a generalization of a Lawvere theory that has the ability to talk about function sorts like $A \Rrightarrow B$ and sums like $A+B$ or $1 + A + A^2 + \cdots,$ more commonly denoted with the Kleene star $A^*.$  One can think of lambda theories as having access to a ``library'' that takes care of the details of bound variables and substitution for us so we do not have to implement all that machinery.  A lambda theory Th(Mach) is a bicartesian closed 2-category equipped with an identity-on-objects functor from $(\FinSet/\Sigma)^{\op}$ to Th(Mach).  Models of Th(Mach) are functors to Cat that preserve all the structure.

The pi calculus was invented in the early 1990s by Robin Milner as a model of asynchronous networks of processes with a dynamically changing topology; two processes initially unaware of each other can be introduced by a third process.  The reflective higher order pi calculus uses quoted processes as names; the term constructors for quote and eval replace the more traditional nu and replicate constructors.  We also add a ``comm'' term to restrict the contexts in which reduction can occur.

Here is a presentation of the multisorted lambda theory Th(RHOpi) for the reflective higher-order pi calculus:
\begin{itemize}
  \item Sorts:
  \begin{itemize}
    \item $N$ for names
    \item $P$ for processes
  \end{itemize}
  \item Term constructors
  \begin{itemize}
    \item $\send\maps N \times P^* \to P$
    \item $\recv\maps N \times (N^* \Rrightarrow P) \to P$
    \item $|\maps P^2 \to P$
    \item $0\maps 1 \to P$
    \item $\comm\maps 1 \to P$
    \item $\quote{-}\maps P \to N$
    \item $\deref{-}\maps N \to P$
  \end{itemize}
  \item Rewrites:
  \begin{itemize}
    \item $\alpha\maps (p_1 | p_2) | p_3 \Rightarrow p_1 | (p_2 | p_3)$
    \item $\beta\maps p_1 | p_2 \Rightarrow p_2 | p_1$
    \item $\iota\maps 0 | p \Rightarrow p$
    \item $\chi\maps (\send(x, p_1, \ldots, p_n) \;|\; \recv(x, q)) \;|\; \comm \Rightarrow q(\quote{p_1}, \ldots, \quote{p_n}) \;|\; \comm$
    \item $\epsilon\maps \deref{\quote{p}} \Rightarrow p$
  \end{itemize}
  \item Equations:
  \begin{itemize}
    \item $\alpha = P^3, \beta = P^2, \iota = P$ (| and 0 form a commutative monoid)
    \item $\epsilon = P$ (evaluating a quoted process is the same as the process itself)
  \end{itemize}
\end{itemize}

The simplest RHOpi processes are 0, the ``do nothing'' process; and comm, a ``catalyst'' process that enables communication on a channel.  In the theory above, comm is preserved by the rewrites; one can think of each comm instance as representing a processor.  An alternative would be to consume comm in the $\chi$ rewrite; then comm would track usage of a processor.  [[ Formal verification of billing for using resources. ]]

[[ Unguessable (quoted processes with no unforgeable names) vs unforgeable (quoted processes with names from the category of generators) ]]

Replication of processes, and therefore general recursion, can be encoded via
\[D(x) = \recv(x, y\mapsto \send(x, \deref{y}) | \deref{y})\]
\[!P = \send(x, D(x) | P) | D(x).\]

Caires' adjunct to | is an instance of our generic modal operator, where $u \triangleright v = u \langle - | - \rangle v:$
\[ \alpha(u \triangleright v) = \{ t \;|\; \exists \rho\maps (t\;|\;u) \Rightarrow v\} \]

\subsubsection{namespaces}

When we add a copy of BoolAlg to RHOpi for both $N$ and $P,$ we can write down formulae that talk about sets of names.  The formula $\top$ denotes the set of all names; the formula $\quote{\top}$ denotes the set of names that are quoted processes.  These two sets differ when we have a nonempty set of generating names.

[[ formula for liveness ]]
\[ \mu X. \recv(\quote{\phi}, x \mapsto X) \]
[[ formula for firewall ]]
\[ \mu X. \recv(\quote{\phi}, x \mapsto X) \land \neg \recv(\quote{\neg\phi}, x \mapsto X) \]
[[ other easy ones? ]]

%\begin{bibliography}
%\bibitem{Graetzer} Gr\"atzer, George. {\em Universal Algebra}, Van Nostrand Co., Inc. (1968) v.
%\end{bibliography}
\end{document}