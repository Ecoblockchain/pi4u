\documentclass[11pt]{article} 

\usepackage{amsfonts,amssymb}
\usepackage{hyperref}

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parskip = 0.1in
\parindent = 0.0in

\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}

\newcommand{\maps}{\colon}
\newcommand{\tensor}{\otimes}
\newcommand{\lhom}{\multimap}
\newcommand{\op}{\mbox{\scriptsize op}}
\newcommand{\too}{\Rightarrow}
\newcommand{\isotoo}{\; \tilde{\Rightarrow} \;}
\newcommand{\mbold}[1]{\mbox{\bf #1}}

\newcommand{\Set}{{\rm Set}}
\newcommand{\Th}{{\rm Th}}
\newcommand{\Cat}{{\rm Cat}}
\newcommand{\End}{{\rm End}}
\newcommand{\Model}{{\rm Model}}


\begin{document} 
\title{Reifying reduction}
\author{Lucius Gregory Meredith\\Michael Stay}
\date{}
\maketitle

Consider the 2-category $\Th(SK)$ with finite products freely generated by the following data:
\begin{enumerate}
  \setcounter{enumi}{-1}
  \item one object $T$,
  \item 1-morphisms
    \begin{itemize}
      \item $S\maps 1 \to T$
      \item $K\maps 1 \to T$
      \item $(-\, -)\maps T \times T \to T,$ and
    \end{itemize}
  \item 2-morphisms
    \begin{itemize}
      \item $\sigma\maps (((S\, x)\, y)\, z) \Rightarrow ((x\, z)\, (y\, z))$
      \item $\kappa\maps ((K\, x)\, y) \Rightarrow x.$
    \end{itemize}
\end{enumerate}

There is a forgetful functor $U$ from the functor 2-category $\Model(SK) = \hom(\Th(SK), \Cat)$ to Cat with a left adjoint $F:\Cat \to \Model(SK).$  The free $SK-$calculus on a category adjoins objects $S$ and $K$ and all binary products; it also adjoins morphisms for reducing $S$ and $K$ in head position applied to three and two terms, respectively.  The free $SK-$calculus on the empty category $\emptyset$ is a category $F\emptyset$ whose 
\begin{enumerate}
  \setcounter{enumi}{-1}
  \item objects are terms of the calculus and whose
  \item morphisms are reductions in the calculus
\end{enumerate}
equipped with structural functors and natural transformations.  

Let $\End(F\emptyset)$ be the monoidal category of structural endofunctors and structural transformations between them.  We get a category $C$ by viewing $\End(F\emptyset)$ as a one-object 2-category and modding out by the 2-morphisms.  The category $C$ has
\begin{enumerate}
  \setcounter{enumi}{-1}
  \item one object and
  \item a morphism for each equivalence class of terms in the calculus,
\end{enumerate}
where terms $t$ and $u$ are equivalent if there exist some term $v$ and 2-cells $t\Rightarrow v$ and $u\Rightarrow v$.  Standard results on abstraction elimination from lambda calculus show that the category $C$ is cartesian closed, where the one object is the type $X \cong X^X$ of the ``untyped'' $SK-$calculus, and Scott domains provide models of $C$ in Set.

All that said, lazy languages don't reduce arguments until they are needed, and even eager functional languages like JavaScript, Perl, Python, and Ruby don't reduce under a binder.  [[Cite Abramsky and Ong, stuff on deriving the LTS from the term contexts for doing bisimilarity, and that paper on  \href{https://users.dimi.uniud.it/~pietro.digianantonio/papers/socl.pdf}{reactive systems}.]]  If we try to model reductions to weak head normal form as 2-morphisms, however, we can whisker the 2-morphism $\sigma$ by the 1-morphism $(S\, -)$ and get a reduction of an argument, which violates the reduction strategy.  While this is not much of a problem for a confluent calculus like the $SK-$calculus, it completely destroys the semantics of calculi like $\pi-$calculus, where the binders denote {\em waiting} for a message on a channel.

We propose to model reduction contexts explicitly with a 1-morphism $R$, adding 2-morphisms to describe the propagation of the context, and modifying the existing reduction 2-morphisms to refer to $R$.  In the example of the $SK-$calculus with lazy reduction, we have
\begin{itemize}
  \item a 1-morphism $R\maps T \to T,$
  \item a 2-isomorphism $\rho\maps R(x\, y) \stackrel{\sim}{\Rightarrow} (Rx\, y),$
  \item a 2-morphism $\sigma'\maps R(((S\, x)\, y)\, z) \Rightarrow R((x\, z)\, (y\, z)),$ and
  \item a 2-morphism $\kappa'\maps R((K\, x)\, y) \Rightarrow Rx.$
\end{itemize}
The morphism $R$ behaves something like a catalyst, enabling a term to reduce.  The 2-morphism $\rho$ acts linearly on $R,$ preserving the amount of catalyst available while moving it from one part of the term to another up and down the left side of the tree of applications.

[[What happens if we mod out by rho, sigma', and kappa'?  Do we still get a cartesian closed category?  How does it differ from the one above?  Can we prove something about full abstraction or something else to show that it really does capture the intended semantics?]]


\begin{thebibliography}{99}
\end{thebibliography} 
\end{document} 
